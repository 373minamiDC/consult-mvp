<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>コンサル資料キット（iPad対応MVP）</title>
<style>
  :root { --bg:#f7f8fa; --panel:#ffffff; --line:#e5e7eb; --hover:#f0f3f8; --accent:#2563eb; }
  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#1f2937; }
  #wrap { display:flex; height:100%; }

  /* 左サイドバー */
  #sidebar {
    width:340px; max-width:42vw; min-width:270px;
    background:var(--panel); border-right:1px solid var(--line);
    display:flex; flex-direction:column; gap:14px; padding:14px; box-sizing:border-box;
  }
  #sidebar h2 { font-size:14px; margin:0 0 6px; color:#374151; }
  .section { padding:10px; border:1px solid var(--line); border-radius:12px; background:#fff; }
  .row { display:flex; gap:8px; }
  .full { width:100%; }
  .muted { color:#6b7280; font-size:12px; margin-top:6px; }
  button, label.as-btn, select, input[type=text] {
    font-size:14px; border:1px solid var(--line); border-radius:10px; background:#fff; color:#111827;
    padding:8px 10px; box-sizing:border-box; cursor:pointer;
  }
  button:hover, label.as-btn:hover { background:var(--hover); }
  button.active { outline:2px solid var(--accent); outline-offset:-2px; }
  input[type=file] { display:none; }
  input[type=text] { width:100%; }
  label.as-btn { display:block; width:100%; text-align:center; }

  /* 色スウォッチ */
  .swatch { width:28px; height:28px; border-radius:7px; border:1px solid var(--line); cursor:pointer; }
  .swatch.active { outline:2px solid var(--accent); outline-offset:-2px; }

  /* 右側キャンバス */
  #main { flex:1; display:flex; flex-direction:column; min-width:0; }
  #canvasPane { flex:1; position:relative; margin:12px; border:1px solid var(--line); border-radius:12px; background:#fff; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; background:#fff; touch-action:none; }
  #hint { position:absolute; right:10px; bottom:10px; background:#0007; color:#fff; font-size:12px; padding:6px 8px; border-radius:8px; }

  @media (max-width: 900px) {
    #wrap { flex-direction:column; }
    #sidebar { width:auto; max-width:none; border-right:none; border-bottom:1px solid var(--line); }
    #canvasPane { margin:10px; height:calc(100vh - 420px); }
  }
</style>
</head>
<body>
<div id="wrap">

  <!-- 左サイドバー -->
  <aside id="sidebar">

    <!-- ページ -->
    <div class="section">
      <h2>ページ</h2>
      <div class="row">
        <button id="prevPageBtn" class="full">◀︎ 前</button>
        <div id="pageIndicator" class="full" style="text-align:center; padding:8px;">1 / 1</div>
        <button id="nextPageBtn" class="full">次 ▶︎</button>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="addPageBtn" class="full">ページ追加</button>
        <button id="deletePageBtn" class="full">現在ページ削除</button>
      </div>
      <div class="muted">※ ページごとに背景・スタンプ・線を保持します</div>
    </div>

    <!-- 患者情報 -->
    <div class="section">
      <h2>患者情報</h2>
      <div class="row"><input id="ptName" class="full" type="text" placeholder="患者名"></div>
      <div class="row" style="margin-top:6px"><input id="ptId" class="full" type="text" placeholder="ID / 診察券番号"></div>
      <div class="muted">左上に小さく表示（保存にも反映）</div>
    </div>

    <!-- 保存・共有 -->
    <div class="section">
      <h2>患者データ保存 / 共有</h2>
      <div class="row">
        <button id="exportPatientBtn" class="full">患者データを書き出し</button>
      </div>
      <label class="as-btn" style="margin-top:6px"><input id="importPatientInput" type="file" accept="application/json">患者データを読み込む</label>
      <div class="muted">※ 保存したJSONをAirDropなどで共有すると他のiPadでも続きを開けます</div>
    </div>

    <!-- 描画 -->
    <div class="section">
      <h2>描画ツール</h2>
      <div class="row">
        <button id="penBtn" class="full active">ペン</button>
        <button id="hlBtn" class="full">蛍光</button>
        <button id="selectBtn" class="full" title="スタンプの移動・回転・サイズ変更">選択</button>
      </div>
      <div class="row" style="margin-top:8px; align-items:center">
        <div id="colorBlack" class="swatch active" title="黒"  style="background:#111"></div>
        <div id="colorRed"   class="swatch"        title="赤"  style="background:#e11d48"></div>
        <div id="colorBlue"  class="swatch"        title="青"  style="background:#2563eb"></div>
        <div id="colorYel"   class="swatch"        title="黄"  style="background:#f59e0b"></div>
        <span class="muted" style="margin-left:6px">※色はペンのみ</span>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="undoBtn" class="full">元に戻す</button>
        <button id="clearPenBtn" class="full" title="手描きのみクリア">描画クリア</button>
      </div>
    </div>

    <!-- 画像・QR・スタンプ -->
    <div class="section">
      <h2>画像・QR・既定スタンプ</h2>
      <label class="as-btn"><input id="bgInput" type="file" accept="image/*">背景画像を読み込む</label>
      <button id="qrBtn" class="full" title="URL/テキストを入力してQR配置">自由入力のQRを追加</button>
      <div class="row" style="margin-top:8px">
        <button id="implantBtn" class="full" title="インプラントスタンプ">インプラント</button>
        <button id="crownBtn" class="full" title="被せ物（クラウン）スタンプ">被せ物</button>
      </div>
      <button id="clearAllBtn" class="full" style="margin-top:8px" title="現在ページを全消去">現在ページ 全消去</button>
    </div>

    <!-- 説明QRプリセット -->
    <div class="section">
      <h2>説明QR（プリセット）</h2>
      <div class="row">
        <select id="qrPresetSelect" class="full"></select>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="placePresetBtn" class="full">この説明をQRで配置</button>
      </div>
      <div class="row" style="margin-top:10px">
        <input id="presetLabel" class="full" type="text" placeholder="追加ラベル（例：インプラント説明）">
      </div>
      <div class="row" style="margin-top:6px">
        <input id="presetData" class="full" type="text" placeholder="URL または テキスト">
      </div>
      <div class="row" style="margin-top:6px">
        <button id="addPresetBtn" class="full">候補を追加</button>
      </div>
      <div class="muted">※ 候補はブラウザに保存され、次回も表示されます</div>
    </div>

    <!-- 表示・出力 -->
    <div class="section">
      <h2>表示 / 出力</h2>
      <div class="row">
        <button id="toggleLinesBtn" class="full">罫線 ON/OFF</button>
        <button id="saveBtn" class="full">PDF保存（全ページ）</button>
      </div>
    </div>

  </aside>

  <!-- 右側キャンバス -->
  <main id="main">
    <div id="canvasPane">
      <canvas id="c"></canvas>
      <div id="hint">1本指:描く/選択　2本指:パン&ズーム　上の丸=回転　右下=拡大縮小</div>
    </div>
  </main>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
/* =========================
   基本セットアップ
========================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:true, desynchronized:true });
const pane = document.getElementById('canvasPane');

let tool = 'pen'; // 'pen' | 'hl' | 'select'
let lineWidthPen = 3;
let lineWidthHL  = 16;
let penColor = '#111'; // 初期は黒

/* 罫線 */
let showLines = true;
const LINE_STEP = 30;

/* ページ：各ページごとにデータを持つ */
let pages = [makeEmptyPage()];
let pageIndex = 0;
function currentPage(){ return pages[pageIndex]; }
function makeEmptyPage(){
  return {
    strokes: [], // {mode,width,color?,points}
    items: [],   // {type,img,x,y,w,h,angle}
    bg: null     // {img,x,y,w,h,angle}
  };
}

/* ビュー（パン＆ズーム）は全ページ共通 */
const view = { scale:1, tx:0, ty:0 };
const MIN_SCALE = 0.3, MAX_SCALE = 6;

const HANDLE_SIZE = 12;
const ROT_HANDLE_OFFSET = 24;

/* =========================
   DPRとサイズ
========================= */
function setCanvasSize(){
  const dpr = window.devicePixelRatio || 1;
  const r = canvas.getBoundingClientRect();
  const w = Math.floor(r.width*dpr), h = Math.floor(r.height*dpr);
  if (canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; }
  redraw();
}
new ResizeObserver(setCanvasSize).observe(pane);

/* =========================
   変換
========================= */
function applyView(){
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.transform(view.scale,0,0,view.scale,view.tx,view.ty);
}
function screenToLogical(pt){ return { x:(pt.x - view.tx)/view.scale, y:(pt.y - view.ty)/view.scale }; }

/* =========================
   レンダリング
========================= */
function clearDevice(){ ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); }

function redraw(){
  clearDevice();
  applyView();

  const pg = currentPage();

  if (showLines) drawHorizontalLines(LINE_STEP);
  if (pg.bg) drawPlacedImage(pg.bg);
  for (let i=0;i<pg.items.length;i++) drawPlacedImage(pg.items[i]);
  for (const s of pg.strokes) drawStroke(s);
  if (current) drawStroke(current);
  if (pg.bg && bgSelected) drawSelectionHandles(pg.bg);
  if (selectedIdx>=0 && pg.items[selectedIdx]) drawSelectionHandles(pg.items[selectedIdx]);

  drawPatientInfo();
  updatePageIndicator();
}

function drawHorizontalLines(step){
  ctx.save();
  ctx.strokeStyle = '#e5e7eb';
  ctx.lineWidth = 1 / view.scale;
  const w = canvas.width / view.scale, h = canvas.height / view.scale;
  const startX = -view.tx / view.scale, startY = -view.ty / view.scale;
  const endX = startX + w, endY = startY + h;
  ctx.beginPath();
  const y0 = Math.floor(startY / step) * step;
  for (let y = y0; y < endY; y += step) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
  ctx.stroke();
  ctx.restore();
}

function drawStroke(s){
  if (!s.points || s.points.length<2) return;
  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';
  if (s.mode==='pen'){ ctx.globalAlpha=1; ctx.strokeStyle=s.color||'#111'; ctx.lineWidth=s.width||lineWidthPen; }
  else { ctx.globalAlpha=0.28; ctx.strokeStyle='#ffd600'; ctx.lineWidth=s.width||lineWidthHL; }
  ctx.beginPath(); ctx.moveTo(s.points[0].x,s.points[0].y);
  for (let i=1;i<s.points.length;i++) ctx.lineTo(s.points[i].x,s.points[i].y);
  ctx.stroke(); ctx.restore();
}

function getItemCenter(it){ return { cx: it.x + it.w/2, cy: it.y + it.h/2 }; }

function drawPlacedImage(it){
  const {cx, cy} = getItemCenter(it);
  ctx.save();
  ctx.translate(cx, cy); ctx.rotate(it.angle || 0);
  ctx.drawImage(it.img, -it.w/2, -it.h/2, it.w, it.h);
  ctx.restore();
}

function drawSelectionHandles(it){
  const {cx, cy} = getItemCenter(it);
  ctx.save();
  ctx.translate(cx, cy); ctx.rotate(it.angle || 0);
  ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 1 / view.scale;
  ctx.setLineDash([4 / view.scale, 3 / view.scale]);
  ctx.strokeRect(-it.w/2, -it.h/2, it.w, it.h);
  ctx.setLineDash([]);

  const r = HANDLE_SIZE/2;
  ctx.fillStyle = '#2563eb';
  ctx.fillRect(it.w/2 - r, it.h/2 - r, HANDLE_SIZE, HANDLE_SIZE);

  const rotY = -it.h/2 - ROT_HANDLE_OFFSET;
  ctx.beginPath(); ctx.moveTo(0, -it.h/2); ctx.lineTo(0, rotY); ctx.stroke();
  ctx.beginPath(); ctx.arc(0, rotY, HANDLE_SIZE*0.6, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawPatientInfo(){
  const name = document.getElementById('ptName').value.trim();
  const id   = document.getElementById('ptId').value.trim();
  if (!name && !id) return;
  ctx.save();
  ctx.fillStyle = '#374151';
  ctx.font = `${12 / view.scale}px system-ui, sans-serif`;
  ctx.textBaseline = 'top';
  ctx.fillText(`${name}${name && id ? ' ' : ''}${id}`, 10, 10);
  ctx.restore();
}

/* =========================
   患者データ保存 / 読み込み
========================= */
const PATIENT_EXPORT_VERSION = 1;

function imageToDataURL(img){
  try {
    const w = img.naturalWidth || img.width;
    const h = img.naturalHeight || img.height;
    if (!w || !h) return null;
    const off = document.createElement('canvas');
    off.width = w; off.height = h;
    const g = off.getContext('2d');
    g.drawImage(img, 0, 0, w, h);
    return off.toDataURL('image/png');
  } catch (err) {
    console.warn('画像をデータURLに変換できませんでした', err);
    return null;
  }
}

function dataURLToImage(dataUrl){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=> resolve(img);
    img.onerror = ()=> reject(new Error('画像の読み込みに失敗しました'));
    img.src = dataUrl;
  });
}

async function serializePatientData(){
  const patient = {
    name: document.getElementById('ptName').value.trim(),
    id: document.getElementById('ptId').value.trim()
  };

  const serializedPages = [];
  let missingImages = false;
  for (const pg of pages){
    const strokes = pg.strokes.map(s=>({
      mode: s.mode,
      width: s.width,
      color: s.color,
      points: s.points.map(p=>({x:p.x, y:p.y}))
    }));

    const items = [];
    for (const it of pg.items){
      const imageData = imageToDataURL(it.img);
      if (!imageData) missingImages = true;
      items.push({
        type: it.type,
        x: it.x,
        y: it.y,
        w: it.w,
        h: it.h,
        angle: it.angle || 0,
        imageData,
        qrData: it.type==='qr' && it.qrData ? it.qrData : undefined
      });
    }

    let bg = null;
    if (pg.bg){
      const imageData = imageToDataURL(pg.bg.img);
      if (!imageData) missingImages = true;
      bg = {
        x: pg.bg.x,
        y: pg.bg.y,
        w: pg.bg.w,
        h: pg.bg.h,
        angle: pg.bg.angle || 0,
        imageData
      };
    }

    serializedPages.push({ strokes, items, bg });
  }

  const payload = {
    version: PATIENT_EXPORT_VERSION,
    exportedAt: new Date().toISOString(),
    patient,
    showLines,
    view: { scale:view.scale, tx:view.tx, ty:view.ty },
    pages: serializedPages
  };

  return { payload, missingImages };
}

async function restorePatientData(data){
  if (!data || typeof data !== 'object'){ throw new Error('形式が正しくありません'); }

  const newPages = [];
  const pageList = Array.isArray(data.pages) ? data.pages : [];
  for (const pgData of pageList){
    const pg = makeEmptyPage();
    pg.strokes = Array.isArray(pgData.strokes) ? pgData.strokes.map(s=>({
      mode: s.mode === 'hl' ? 'hl' : 'pen',
      width: typeof s.width === 'number' ? s.width : (s.mode === 'hl' ? lineWidthHL : lineWidthPen),
      color: s.color,
      points: Array.isArray(s.points) ? s.points.map(p=>({x:p.x, y:p.y})) : []
    })) : [];

    pg.items = [];
    if (Array.isArray(pgData.items)){
      for (const item of pgData.items){
        if (!item || !item.imageData) continue;
        try {
          const img = await dataURLToImage(item.imageData);
          const restored = {
            type: item.type || 'qr',
            img,
            x: typeof item.x === 'number' ? item.x : 0,
            y: typeof item.y === 'number' ? item.y : 0,
            w: typeof item.w === 'number' ? item.w : (img.naturalWidth || img.width),
            h: typeof item.h === 'number' ? item.h : (img.naturalHeight || img.height),
            angle: typeof item.angle === 'number' ? item.angle : 0
          };
          if (restored.type === 'qr' && item.qrData) restored.qrData = item.qrData;
          pg.items.push(restored);
        } catch (err) {
          console.warn('スタンプの復元に失敗しました', err);
        }
      }
    }

    if (pgData.bg && pgData.bg.imageData){
      try {
        const bgImg = await dataURLToImage(pgData.bg.imageData);
        pg.bg = {
          img: bgImg,
          x: typeof pgData.bg.x === 'number' ? pgData.bg.x : 0,
          y: typeof pgData.bg.y === 'number' ? pgData.bg.y : 0,
          w: typeof pgData.bg.w === 'number' ? pgData.bg.w : (bgImg.naturalWidth || bgImg.width),
          h: typeof pgData.bg.h === 'number' ? pgData.bg.h : (bgImg.naturalHeight || bgImg.height),
          angle: typeof pgData.bg.angle === 'number' ? pgData.bg.angle : 0
        };
      } catch (err) {
        console.warn('背景の復元に失敗しました', err);
      }
    }

    newPages.push(pg);
  }

  pages = newPages.length ? newPages : [makeEmptyPage()];
  pageIndex = 0;
  selectedIdx = -1;
  bgSelected = false;
  current = null;
  drawing = false;
  dragState = null;
  pinchStart = null;
  pointers.clear();

  const patient = data.patient || {};
  document.getElementById('ptName').value = patient.name || '';
  document.getElementById('ptId').value = patient.id || '';

  if (typeof data.showLines === 'boolean') showLines = data.showLines;

  if (data.view){
    if (typeof data.view.scale === 'number'){
      view.scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, data.view.scale));
    }
    view.tx = typeof data.view.tx === 'number' ? data.view.tx : 0;
    view.ty = typeof data.view.ty === 'number' ? data.view.ty : 0;
  } else {
    view.scale = 1; view.tx = 0; view.ty = 0;
  }

  redraw();
}

function sanitizeFileName(str){
  return str.replace(/[\\/:*?"<>|]/g, '_').slice(0, 40) || 'patient';
}

/* =========================
   背景・QR・既定スタンプ（ページ単位）
========================= */
document.getElementById('bgInput').addEventListener('change', (ev)=>{
  const file = ev.target.files?.[0]; if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = ()=>{
    const pg=currentPage();
    pg.bg={ img, x:0, y:0, w:img.naturalWidth, h:img.naturalHeight, angle:0 };
    selectedIdx=-1; bgSelected=true; redraw(); URL.revokeObjectURL(url);
  };
  img.src = url;
});

document.getElementById('qrBtn').addEventListener('click', ()=>{
  const data = prompt('QRにするURLまたはテキスト：', 'https://minami-dentalclinic.com');
  if (!data) return; placeQR(data);
});

function placeQR(data){
  const size = 240;
  const src = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(data)}`;
  const img = new Image(); img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    const initW=180, initH=180;
    const center = screenToLogical(centerOfCanvas());
    const pg = currentPage();
    pg.items.push({ type:'qr', qrData:data, img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH, angle:0 });
    selectedIdx = pg.items.length - 1; bgSelected=false; redraw();
  };
  img.onerror = ()=> alert('QR画像の取得に失敗しました。ネットワークをご確認ください。');
  img.src = src;
}

document.getElementById('implantBtn').addEventListener('click', ()=>{
  const img = makeImplantStamp(); const initW=180, initH=320;
  const center = screenToLogical(centerOfCanvas());
  const pg = currentPage();
  pg.items.push({ type:'implant', img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH, angle:0 });
  selectedIdx = pg.items.length - 1; bgSelected=false; redraw();
});
document.getElementById('crownBtn').addEventListener('click', ()=>{
  const img = makeCrownStamp(); const initW=260, initH=220;
  const center = screenToLogical(centerOfCanvas());
  const pg = currentPage();
  pg.items.push({ type:'crown', img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH, angle:0 });
  selectedIdx = pg.items.length - 1; bgSelected=false; redraw();
});

/* 既定スタンプ生成 */
function makeImplantStamp(){
  const w=180, h=320, off=document.createElement('canvas'); off.width=w; off.height=h; const g=off.getContext('2d');
  g.clearRect(0,0,w,h);
  g.fillStyle = '#e5e7eb'; g.strokeStyle = '#9ca3af'; g.lineWidth = 2;
  g.beginPath(); g.roundRect(50, 20, 80, 50, 10); g.fill(); g.stroke();
  g.fillStyle = '#d1d5db'; g.fillRect(75, 70, 30, 18);
  g.fillStyle = '#cbd5e1'; g.strokeStyle = '#94a3b8'; g.lineWidth = 2;
  g.beginPath(); g.roundRect(60, 88, 60, 180, 20); g.fill(); g.stroke();
  g.strokeStyle = '#94a3b8'; g.lineWidth = 2;
  for (let y=100;y<250;y+=14){ g.beginPath(); g.moveTo(62,y); g.lineTo(118,y+16); g.stroke(); }
  g.fillStyle = '#cbd5e1'; g.beginPath(); g.moveTo(60,268); g.lineTo(120,268); g.lineTo(90,300); g.closePath(); g.fill(); g.stroke();
  g.fillStyle = 'rgba(0,0,0,0.05)'; g.beginPath(); g.ellipse(90, 310, 45, 8, 0, 0, Math.PI*2); g.fill();
  const img=new Image(); img.src=off.toDataURL('image/png'); return img;
}
function makeCrownStamp(){
  const w=260, h=220, off=document.createElement('canvas'); off.width=w; off.height=h; const g=off.getContext('2d');
  g.clearRect(0,0,w,h);
  g.fillStyle = '#ffffff'; g.strokeStyle = '#94a3b8'; g.lineWidth = 2;
  g.beginPath();
  g.moveTo(40,140);
  g.bezierCurveTo(40,90, 70,60, 110,60);
  g.bezierCurveTo(125,35, 135,30, 150,60);
  g.bezierCurveTo(190,60, 220,90, 220,140);
  g.bezierCurveTo(220,175, 200,190, 130,190);
  g.bezierCurveTo(70,190, 40,175, 40,140);
  g.closePath(); g.fill(); g.stroke();
  g.fillStyle = 'rgba(255,255,255,0.7)'; g.beginPath(); g.ellipse(120,95,60,20,-0.4,0,Math.PI*2); g.fill();
  g.strokeStyle = '#cbd5e1'; g.lineWidth=1.5; g.beginPath(); g.moveTo(90,120); g.quadraticCurveTo(130,110,170,120);
  g.moveTo(110,140); g.quadraticCurveTo(130,135,150,140); g.stroke();
  g.fillStyle = 'rgba(0,0,0,0.06)'; g.beginPath(); g.ellipse(130,205,70,10,0,0,Math.PI*2); g.fill();
  const img=new Image(); img.src=off.toDataURL('image/png'); return img;
}

/* =========================
   当たり判定（回転対応）
========================= */
function worldToLocal(pt, it){
  const {cx, cy} = getItemCenter(it);
  const a = -(it.angle || 0);
  const dx = pt.x - cx, dy = pt.y - cy;
  return { x:  dx*Math.cos(a) - dy*Math.sin(a),
           y:  dx*Math.sin(a) + dy*Math.cos(a) };
}
function localHitTest(ptLocal, it){
  const halfW = it.w/2, halfH = it.h/2;
  const inBody = (ptLocal.x>=-halfW && ptLocal.x<=halfW && ptLocal.y>=-halfH && ptLocal.y<=halfH);
  const r = HANDLE_SIZE/2;
  const inResize = (ptLocal.x>=halfW-r && ptLocal.x<=halfW+r && ptLocal.y>=halfH-r && ptLocal.y<=halfH+r);
  const rotY = -halfH - ROT_HANDLE_OFFSET;
  const inRotate = ((ptLocal.x-0)**2 + (ptLocal.y-rotY)**2) <= (HANDLE_SIZE*0.6)**2;
  return { inBody, inResize, inRotate };
}
function hitTestItem(L){
  const pg=currentPage();
  for (let i=pg.items.length-1;i>=0;i--){
    const it=pg.items[i]; const local=worldToLocal(L,it); const h=localHitTest(local,it);
    if (h.inRotate) return {kind:'rotate', idx:i};
    if (h.inResize) return {kind:'resize', idx:i};
    if (h.inBody)   return {kind:'body',   idx:i};
  }
  return {kind:'none', idx:-1};
}

function hitTestBackground(L){
  const bg=currentPage().bg;
  if (!bg) return {kind:'none', idx:-1};
  const local=worldToLocal(L,bg); const h=localHitTest(local,bg);
  if (h.inRotate) return {kind:'rotate', idx:-1};
  if (h.inResize) return {kind:'resize', idx:-1};
  if (h.inBody)   return {kind:'body',   idx:-1};
  return {kind:'none', idx:-1};
}

/* =========================
   入力処理：描画／選択／パンピンチ
========================= */
const pointers=new Map();
let pinchStart=null; // {mid,dist,view}
let dragState=null;  // {target:'item'|'bg', kind:'move'|'resize'|'rotate', idx, start, itemStart, startAngleScreen?}
let selectedIdx=-1;
let bgSelected=false;
let drawing=false;
let current=null;

function getEventPoint(e){ const r=canvas.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }
function twoFingerInfo(){ const arr=[...pointers.values()]; const p0=arr[0],p1=arr[1];
  return { mid:{x:(p0.x+p1.x)/2, y:(p0.y+p1.y)/2}, dist:Math.hypot(p1.x-p0.x, p1.y-p0.y) }; }
function angleTo(it, ptWorld){ const {cx,cy}=getItemCenter(it); return Math.atan2(ptWorld.y-cy, ptWorld.x-cx); }

canvas.addEventListener('pointerdown',(e)=>{
  e.preventDefault(); canvas.setPointerCapture(e.pointerId);
  const pt=getEventPoint(e); pointers.set(e.pointerId, pt);
  const pg=currentPage();

  if (tool==='select'){
    const L=screenToLogical(pt);
    if (pointers.size===1){
      const hit=hitTestItem(L);
      if (hit.idx>=0){
        selectedIdx=hit.idx; bgSelected=false;
        const it=pg.items[selectedIdx];
        if (hit.kind==='rotate' && (it.type==='implant'||it.type==='crown')){
          dragState={
            target:'item',
            kind:'rotate',
            idx:selectedIdx,
            start:L,
            itemStart:Object.assign({}, it),
            startAngleScreen:angleTo(it,L)
          };
        } else if (hit.kind==='resize'){
          dragState={
            target:'item',
            kind:'resize',
            idx:selectedIdx,
            start:L,
            itemStart:Object.assign({}, it)
          };
        } else if (hit.kind==='body'){
          dragState={
            target:'item',
            kind:'move',
            idx:selectedIdx,
            start:L,
            itemStart:Object.assign({}, it)
          };
        } else {
          dragState=null;
        }
      } else {
        const bgHit=hitTestBackground(L);
        if (bgHit.kind!=='none'){
          selectedIdx=-1; bgSelected=true;
          const bg=pg.bg;
          if (!bg){ dragState=null; }
          else if (bgHit.kind==='rotate'){
            dragState={
              target:'bg',
              kind:'rotate',
              idx:-1,
              start:L,
              itemStart:Object.assign({}, bg),
              startAngleScreen:angleTo(bg,L)
            };
          } else if (bgHit.kind==='resize'){
            dragState={
              target:'bg',
              kind:'resize',
              idx:-1,
              start:L,
              itemStart:Object.assign({}, bg)
            };
          } else if (bgHit.kind==='body'){
            dragState={
              target:'bg',
              kind:'move',
              idx:-1,
              start:L,
              itemStart:Object.assign({}, bg)
            };
          } else {
            dragState=null;
          }
        } else {
          selectedIdx=-1; bgSelected=false; dragState=null;
        }
      }
      redraw();
    }
    if (pointers.size===2){
      const {mid,dist}=twoFingerInfo();
      pinchStart={mid,dist,view:{ scale:view.scale, tx:view.tx, ty:view.ty }};
    }
    return;
  }

  // 描画
  if (pointers.size===1){
    drawing=true;
    current={mode:tool, color:(tool==='pen'?penColor:undefined), width:(tool==='pen'?lineWidthPen:lineWidthHL), points:[screenToLogical(pt)]};
  } else if (pointers.size===2){
    const {mid,dist}=twoFingerInfo();
    pinchStart={mid,dist,view:{ scale:view.scale, tx:view.tx, ty:view.ty }};
  }
  redraw();
},{passive:false});

canvas.addEventListener('pointermove',(e)=>{
  if (!pointers.has(e.pointerId)) return;
  e.preventDefault();
  pointers.set(e.pointerId, getEventPoint(e));
  const pg=currentPage();

  if (tool==='select'){
    if (pointers.size===1 && dragState){
      const L=screenToLogical(pointers.get(e.pointerId));
      const target = dragState.target==='bg' ? pg.bg : pg.items[dragState.idx];
      if (target){
        if (dragState.kind==='move'){
          const dx=L.x-dragState.start.x, dy=L.y-dragState.start.y;
          target.x=dragState.itemStart.x+dx; target.y=dragState.itemStart.y+dy;
        } else if (dragState.kind==='resize'){
          const localNow=worldToLocal(L, dragState.itemStart);
          const halfW0=dragState.itemStart.w/2, halfH0=dragState.itemStart.h/2;
          let newW=Math.max(20, (localNow.x + halfW0)*2);
          let newH=Math.max(20, (localNow.y + halfH0)*2);
          const {cx,cy}=getItemCenter(dragState.itemStart);
          target.w=newW; target.h=newH; target.x=cx-target.w/2; target.y=cy-target.h/2;
        } else if (dragState.kind==='rotate'){
          const ang0=dragState.startAngleScreen; const ang1=angleTo(dragState.itemStart,L);
          target.angle=(dragState.itemStart.angle||0)+(ang1-ang0);
        }
        redraw();
      }
      return;
    }
    if (pointers.size===2){
      const {mid,dist}=twoFingerInfo(); if (!pinchStart) return;
      const base=pinchStart.view; let s=base.scale*(dist/pinchStart.dist);
      s=Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
      const Lx=(pinchStart.mid.x-base.tx)/base.scale; const Ly=(pinchStart.mid.y-base.ty)/base.scale;
      view.scale=s; view.tx=mid.x-Lx*s; view.ty=mid.y-Ly*s; redraw(); return;
    }
    return;
  }

  // 描画
  if (pointers.size===1 && drawing && current){
    current.points.push(screenToLogical(pointers.get(e.pointerId))); redraw();
  } else if (pointers.size===2 && pinchStart){
    const {mid,dist}=twoFingerInfo(); const base=pinchStart.view; let s=base.scale*(dist/pinchStart.dist);
    s=Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
    const Lx=(pinchStart.mid.x-base.tx)/base.scale; const Ly=(pinchStart.mid.y-base.ty)/base.scale;
    view.scale=s; view.tx=mid.x-Lx*s; view.ty=mid.y-Ly*s; redraw();
  }
},{passive:false});

canvas.addEventListener('pointerup',(e)=>{
  e.preventDefault();
  const pg=currentPage();

  if (tool==='select'){ dragState=null; pointers.delete(e.pointerId); if (pointers.size<2) pinchStart=null; return; }

  if (drawing && current && pointers.size===1){
    const pt=pointers.get(e.pointerId); if (pt) current.points.push(screenToLogical(pt));
    pg.strokes.push(current);
  }
  drawing=false; current=null;

  pointers.delete(e.pointerId); if (pointers.size<2) pinchStart=null; redraw();
},{passive:false});

canvas.addEventListener('pointercancel',(e)=>{
  e.preventDefault(); drawing=false; current=null; dragState=null;
  pointers.delete(e.pointerId); if (pointers.size<2) pinchStart=null; redraw();
},{passive:false});

/* =========================
   ツール・ページ操作・保存
========================= */
const btns={ pen:document.getElementById('penBtn'), hl:document.getElementById('hlBtn'), sel:document.getElementById('selectBtn') };
function setTool(next){ tool=next;
  btns.pen.classList.toggle('active', tool==='pen');
  btns.hl .classList.toggle('active', tool==='hl');
  btns.sel.classList.toggle('active', tool==='select');
  if (tool!=='select'){ selectedIdx=-1; bgSelected=false; dragState=null; redraw(); }
}
btns.pen.onclick=()=>setTool('pen');
btns.hl.onclick =()=>setTool('hl');
btns.sel.onclick=()=>setTool('select');

document.getElementById('toggleLinesBtn').onclick=()=>{ showLines=!showLines; redraw(); };

document.getElementById('undoBtn').onclick=()=>{
  const pg=currentPage();
  if (current){ current=null; drawing=false; redraw(); return; }
  if (pg.strokes.length>0){ pg.strokes.pop(); redraw(); return; }
  if (pg.items.length>0){ pg.items.pop(); selectedIdx=-1; bgSelected=false; redraw(); return; }
};
document.getElementById('clearPenBtn').onclick=()=>{ currentPage().strokes.length=0; redraw(); };
document.getElementById('clearAllBtn').onclick=()=>{
  if (!confirm('現在ページの背景/スタンプ/描画をすべて消去します。')) return;
  const pg=currentPage();
  pg.strokes.length=0; pg.items.length=0; pg.bg=null;
  selectedIdx=-1; bgSelected=false; redraw();
};
document.getElementById('saveBtn').onclick=async()=>{
  const jspdf = window.jspdf;
  if (!jspdf || !jspdf.jsPDF){
    alert('PDF生成ライブラリの読み込みに失敗しました。ページを再読み込みして再試行してください。');
    return;
  }

  const rect = canvas.getBoundingClientRect();
  if (!rect.width || !rect.height){
    alert('キャンバスのサイズが取得できませんでした。');
    return;
  }

  const orientation = rect.width >= rect.height ? 'landscape' : 'portrait';
  const pdf = new jspdf.jsPDF({ orientation, unit:'px', format:[rect.width, rect.height] });
  const timestamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');

  const prevState = {
    pageIndex,
    selectedIdx,
    bgSelected,
    current,
    view: { ...view }
  };

  try {
    for (let i=0;i<pages.length;i++){
      pageIndex = i;
      selectedIdx = -1;
      bgSelected = false;
      current = null;
      redraw();

      const dataUrl = await new Promise(resolve=>{
        requestAnimationFrame(()=> resolve(canvas.toDataURL('image/png')));
      });

      if (i>0) pdf.addPage([rect.width, rect.height], orientation);
      pdf.addImage(dataUrl, 'PNG', 0, 0, rect.width, rect.height);
    }

    pdf.save(`consult_pages_${timestamp}.pdf`);
  } catch (err) {
    console.error(err);
    alert('PDFの作成に失敗しました。もう一度お試しください。');
  } finally {
    pageIndex = prevState.pageIndex;
    selectedIdx = prevState.selectedIdx;
    bgSelected = prevState.bgSelected;
    current = prevState.current;
    view.scale = prevState.view.scale;
    view.tx = prevState.view.tx;
    view.ty = prevState.view.ty;
    redraw();
  }
};

document.getElementById('exportPatientBtn').onclick=async()=>{
  try {
    const { payload, missingImages } = await serializePatientData();
    const namePart = sanitizeFileName(payload.patient.id || payload.patient.name || 'patient');
    const timestamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${namePart}_${timestamp}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
    if (missingImages){
      alert('一部の画像を取得できなかったため、書き出したデータに含まれていない可能性があります。');
    }
  } catch (err) {
    console.error(err);
    alert('患者データの書き出しに失敗しました。');
  }
};

document.getElementById('importPatientInput').addEventListener('change', async(ev)=>{
  const file = ev.target.files?.[0];
  if (!file) return;
  try {
    const text = await file.text();
    const data = JSON.parse(text);
    if (data.version && data.version > PATIENT_EXPORT_VERSION){
      const proceed = confirm('新しい形式のファイルです。読み込みを試みますか？');
      if (!proceed) return;
    }
    await restorePatientData(data);
    alert('患者データを読み込みました。');
  } catch (err) {
    console.error(err);
    alert('患者データの読み込みに失敗しました。ファイルをご確認ください。');
  } finally {
    ev.target.value = '';
  }
});

/* ペン色 */
[['colorBlack','#111'],['colorRed','#e11d48'],['colorBlue','#2563eb'],['colorYel','#f59e0b']].forEach(([id,col])=>{
  const el=document.getElementById(id);
  el.addEventListener('click', ()=>{
    ['colorBlack','colorRed','colorBlue','colorYel'].forEach(i=>document.getElementById(i).classList.remove('active'));
    el.classList.add('active'); penColor=col;
  });
});

/* ページ操作 */
document.getElementById('addPageBtn').onclick=()=>{
  pages.splice(pageIndex+1, 0, makeEmptyPage());
  pageIndex++; selectedIdx=-1; bgSelected=false; redraw();
};
document.getElementById('prevPageBtn').onclick=()=>{ if (pageIndex>0){ pageIndex--; selectedIdx=-1; bgSelected=false; redraw(); } };
document.getElementById('nextPageBtn').onclick=()=>{ if (pageIndex<pages.length-1){ pageIndex++; selectedIdx=-1; bgSelected=false; redraw(); } };
document.getElementById('deletePageBtn').onclick=()=>{
  if (pages.length===1){ alert('これ以上削除できません'); return; }
  if (!confirm(`ページ${pageIndex+1}を削除しますか？`)) return;
  pages.splice(pageIndex,1);
  pageIndex = Math.max(0, Math.min(pageIndex, pages.length-1));
  selectedIdx=-1; bgSelected=false; redraw();
};
function updatePageIndicator(){
  const el=document.getElementById('pageIndicator');
  el.textContent = `${pageIndex+1} / ${pages.length}`;
}

/* =========================
   説明QRプリセット（localStorage）
========================= */
const PRESET_KEY = 'consult_qr_presets_v2';
const DEFAULT_PRESETS = [
  {label:'補綴物', data:'https://minami-dentalclinic.com/クラウンによる歯冠修復治療/'},
  {label:'CR', data:'https://minami-dentalclinic.com/コンポジットレジン修復（cr修復%EF%BC%8Fcr充填）/'},
  {label:'インレー', data:'https://minami-dentalclinic.com/インレー修復/'},
  {label:'ブリッジ', data:'https://minami-dentalclinic.com/ブリッジ/'},
  {label:'歯周治療', data:'https://minami-dentalclinic.com/歯周病治療/'},
  {label:'抜髄治療', data:'https://minami-dentalclinic.com/抜髄治療/'},
  {label:'感染根管治療', data:'https://minami-dentalclinic.com/感染根管治療/'},
  {label:'総義歯', data:'https://minami-dentalclinic.com/総義歯/'},
  {label:'部分床義歯', data:'https://minami-dentalclinic.com/部分床義歯/'},
  {label:'インプラント', data:'https://minami-dentalclinic.com/インプラント/'},
  {label:'中間欠損', data:'https://minami-dentalclinic.com/１歯欠損で両隣に歯がある場合の治療法（インプ/'},
  {label:'7番欠損', data:'https://minami-dentalclinic.com/７番欠損（６番は残存）時の治療法/'}
];
function loadPresets(){
  const raw = localStorage.getItem(PRESET_KEY);
  let presets = [];
  if (raw){ try{ presets = JSON.parse(raw)||[]; }catch{} }
  if (presets.length===0){
    presets = DEFAULT_PRESETS.slice();
    localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
  }
  return presets;
}
function savePresets(list){ localStorage.setItem(PRESET_KEY, JSON.stringify(list)); }
function refreshPresetSelect(){
  const sel = document.getElementById('qrPresetSelect');
  const presets = loadPresets();
  sel.innerHTML = '';
  presets.forEach((p,i)=>{
    const opt = document.createElement('option');
    opt.value = String(i); opt.textContent = p.label;
    sel.appendChild(opt);
  });
}
document.getElementById('placePresetBtn').onclick=()=>{
  const i = parseInt(document.getElementById('qrPresetSelect').value, 10);
  const list = loadPresets();
  if (isNaN(i) || !list[i]) { alert('候補を選択してください'); return; }
  placeQR(list[i].data);
};
document.getElementById('addPresetBtn').onclick=()=>{
  const label = document.getElementById('presetLabel').value.trim();
  const data  = document.getElementById('presetData').value.trim();
  if (!label || !data){ alert('ラベルとURL/テキストを入力してください'); return; }
  const list = loadPresets(); list.push({label, data}); savePresets(list);
  document.getElementById('presetLabel').value=''; document.getElementById('presetData').value='';
  refreshPresetSelect(); alert('候補を追加しました');
};

/* ユーティリティ */
function centerOfCanvas(){ const r=canvas.getBoundingClientRect(); return {x:r.width/2, y:r.height/2}; }

/* 初期化 */
refreshPresetSelect();
setCanvasSize();
</script>
</body>
</html>
