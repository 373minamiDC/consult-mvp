<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>コンサル資料キット（iPad対応MVP）</title>
<style>
  :root { --bg:#f7f8fa; --panel:#ffffff; --line:#e5e7eb; --hover:#f0f3f8; --accent:#2563eb; }
  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#1f2937; }
  #wrap { display:flex; height:100%; }

  /* 左サイドバー */
  #sidebar {
    width:320px; max-width:40vw; min-width:260px;
    background:var(--panel); border-right:1px solid var(--line);
    display:flex; flex-direction:column; gap:14px; padding:14px; box-sizing:border-box;
  }
  #sidebar h2 { font-size:14px; margin:0 0 6px; color:#374151; }
  .section { padding:10px; border:1px solid var(--line); border-radius:12px; background:#fff; }
  .row { display:flex; gap:8px; }
  .full { width:100%; }
  .muted { color:#6b7280; font-size:12px; margin-top:6px; }

  /* 操作系 */
  button, label.as-btn, select, input[type=text] {
    font-size:14px; border:1px solid var(--line); border-radius:10px; background:#fff; color:#111827;
    padding:8px 10px; box-sizing:border-box; cursor:pointer;
  }
  button:hover, label.as-btn:hover { background:var(--hover); }
  button.active { outline:2px solid var(--accent); outline-offset:-2px; }
  input[type=file] { display:none; }
  input[type=text] { width:100%; }

  /* 右側キャンバス */
  #main { flex:1; display:flex; flex-direction:column; min-width:0; }
  #canvasPane { flex:1; position:relative; margin:12px; border:1px solid var(--line); border-radius:12px; background:#fff; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; background:#fff; touch-action:none; }
  #hint { position:absolute; right:10px; bottom:10px; background:#0007; color:#fff; font-size:12px; padding:6px 8px; border-radius:8px; }

  /* 小画面でサイドバーを上に */
  @media (max-width: 900px) {
    #wrap { flex-direction:column; }
    #sidebar { width:auto; max-width:none; border-right:none; border-bottom:1px solid var(--line); }
    #canvasPane { margin:10px; height:calc(100vh - 280px); }
  }
</style>
</head>
<body>
<div id="wrap">

  <!-- 左サイドバー -->
  <aside id="sidebar">
    <div class="section">
      <h2>患者情報</h2>
      <div class="row">
        <input id="ptName" class="full" type="text" placeholder="患者名（任意）">
      </div>
      <div class="row" style="margin-top:6px">
        <input id="ptId" class="full" type="text" placeholder="ID / 診察券番号（任意）">
      </div>
      <div class="muted">※ 表示や保存には影響しません（将来の自動記載用プレースホルダ）</div>
    </div>

    <div class="section">
      <h2>描画ツール</h2>
      <div class="row">
        <button id="penBtn" class="full active">ペン</button>
        <button id="hlBtn" class="full">蛍光</button>
        <button id="selectBtn" class="full" title="画像/QRの移動・サイズ変更">選択</button>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="undoBtn" class="full">元に戻す</button>
        <button id="clearPenBtn" class="full" title="手描きのみクリア">描画クリア</button>
      </div>
      <div class="muted">1本指:描く/選択　2本指:パン&ズーム</div>
    </div>

    <div class="section">
      <h2>画像・QR・表</h2>
      <label class="as-btn full"><input id="bgInput" type="file" accept="image/*">背景画像を読み込む</label>
      <label class="as-btn full"><input id="stampInput" type="file" accept="image/*">スタンプ画像を追加</label>
      <button id="qrBtn" class="full" title="URLやテキストからQR生成">QRを追加</button>
      <button id="tableBtn" class="full" title="治療計画の空欄マス目を追加">治療計画表を追加</button>
      <button id="clearAllBtn" class="full" style="margin-top:6px" title="背景/スタンプ/描画すべて消去">全消去</button>
    </div>

    <div class="section">
      <h2>出力</h2>
      <button id="saveBtn" class="full">PNGとして保存</button>
      <div class="muted">※ iPadは「プリント→ピンチ拡大→共有」でPDF化も可能</div>
    </div>
  </aside>

  <!-- 右側キャンバス -->
  <main id="main">
    <div id="canvasPane">
      <canvas id="c"></canvas>
      <div id="hint">1本指:描く/選択　2本指:パン&ズーム　右下ハンドル:サイズ変更</div>
    </div>
  </main>

</div>

<script>
/* =========================
   1) 基本セットアップ
========================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:true, desynchronized:true });
const pane = document.getElementById('canvasPane');

let tool = 'pen'; // 'pen' | 'hl' | 'select'
let lineWidthPen = 3;
let lineWidthHL  = 16;

/* =========================
   2) 論理モデル
========================= */
// 手描き（論理座標に保存）
const strokes = []; // [{mode:'pen'|'hl', width:number, points:[{x,y}]}]
let drawing = false;
let current = null;

// 背景（下敷き）
let bgImg = null;                // HTMLImageElement
let bgSize = { w:0, h:0 };       // 論理サイズ

// オブジェクト（画像スタンプ／QR／表）
/* item: { type:'stamp'|'qr'|'table', img:HTMLImageElement, x,y,w,h }  ※論理座標 */
const items = [];
let selectedIdx = -1;
const HANDLE_SIZE = 12;          // 論理座標上のハンドルサイズ

// ビュー（パン＆ズーム）
const view = { scale:1, tx:0, ty:0 };
const MIN_SCALE = 0.3, MAX_SCALE = 6;

/* =========================
   3) DPRとキャンバスサイズ
========================= */
function setCanvasSize() {
  const dpr = window.devicePixelRatio || 1;
  const r = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(r.width * dpr));
  const h = Math.max(1, Math.floor(r.height * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
  }
  redraw();
}
new ResizeObserver(setCanvasSize).observe(pane);
window.addEventListener('resize', setCanvasSize, { passive:true });

/* =========================
   4) 座標変換
========================= */
function applyView() {
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr,0,0,dpr,0,0);             // まずピクセル1:1
  ctx.transform(view.scale,0,0,view.scale,view.tx,view.ty); // そこからビュー適用
}
function screenToLogical(pt) { return { x:(pt.x - view.tx)/view.scale, y:(pt.y - view.ty)/view.scale }; }
function logicalToScreen(pt) { return { x:pt.x*view.scale + view.tx, y:pt.y*view.scale + view.ty }; }

/* =========================
   5) レンダリング
========================= */
function clearDevice() {
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
}
function redraw() {
  clearDevice();
  applyView();

  // 背景
  if (bgImg && bgSize.w>0 && bgSize.h>0) {
    ctx.drawImage(bgImg, 0, 0, bgSize.w, bgSize.h);
  }

  // オブジェクト（スタンプ/QR/表）
  for (let i=0;i<items.length;i++) drawItem(items[i], i===selectedIdx);

  // 手描き
  for (const s of strokes) drawStroke(s);
  if (current) drawStroke(current);
}

function drawStroke(s) {
  if (!s.points || s.points.length < 2) return;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.miterLimit = 2;
  if (s.mode === 'pen') {
    ctx.globalAlpha = 1.0; ctx.strokeStyle = '#111'; ctx.lineWidth = s.width ?? lineWidthPen;
  } else {
    ctx.globalAlpha = 0.28; ctx.strokeStyle = '#ffd600'; ctx.lineWidth = s.width ?? lineWidthHL;
  }
  ctx.beginPath();
  ctx.moveTo(s.points[0].x, s.points[0].y);
  for (let i=1;i<s.points.length;i++) ctx.lineTo(s.points[i].x, s.points[i].y);
  ctx.stroke();
  ctx.restore();
}

function drawItem(it, selected) {
  ctx.drawImage(it.img, it.x, it.y, it.w, it.h);
  if (!selected) return;
  // 選択枠＆ハンドル
  ctx.save();
  ctx.strokeStyle = '#2563eb';
  ctx.lineWidth = 1 / view.scale;
  ctx.setLineDash([4 / view.scale, 3 / view.scale]);
  ctx.strokeRect(it.x, it.y, it.w, it.h);
  ctx.setLineDash([]);
  const r = HANDLE_SIZE/2;
  const hx = it.x + it.w, hy = it.y + it.h;
  ctx.fillStyle = '#2563eb';
  ctx.fillRect(hx - r, hy - r, HANDLE_SIZE, HANDLE_SIZE);
  ctx.restore();
}

/* =========================
   6) 背景・スタンプ・QR・表
========================= */
document.getElementById('bgInput').addEventListener('change', (ev)=>{
  const file = ev.target.files?.[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = ()=>{
    bgImg = img;
    bgSize.w = img.naturalWidth; bgSize.h = img.naturalHeight;
    // 自動フィットは行わない（ご要望どおり）
    redraw();
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

document.getElementById('stampInput').addEventListener('change', (ev)=>{
  const file = ev.target.files?.[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = ()=>{
    const initW = Math.min(600, img.naturalWidth);
    const scale = initW / img.naturalWidth;
    const initH = img.naturalHeight * scale;
    const center = screenToLogical(centerOfCanvas());
    items.push({ type:'stamp', img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH });
    selectedIdx = items.length - 1;
    redraw();
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

document.getElementById('qrBtn').addEventListener('click', ()=>{
  const data = prompt('QRにするURLまたはテキスト：', 'https://minami-dentalclinic.com');
  if (!data) return;
  const size = 512;
  const src = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(data)}`;
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    const initW = 240, initH = 240;
    const center = screenToLogical(centerOfCanvas());
    items.push({ type:'qr', img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH });
    selectedIdx = items.length - 1;
    redraw();
  };
  img.onerror = ()=> alert('QR画像の取得に失敗しました。ネットワークをご確認ください。');
  img.src = src;
});

/* === 治療計画表（空欄マス目）スタンプの生成 === */
document.getElementById('tableBtn').addEventListener('click', ()=>{
  // 簡単な入力（空ENTERでデフォルト）
  const cols = Math.max(1, parseInt(prompt('列数（例: 6）', '6') || '6', 10));
  const rows = Math.max(1, parseInt(prompt('行数（例: 4）', '4') || '4', 10));
  const cell = Math.max(20, parseInt(prompt('1マスの大きさpx（例: 80）', '80') || '80', 10));
  const img = makeGridStamp(cols, rows, cell);
  const initW = cols * cell;
  const initH = rows * cell;
  const center = screenToLogical(centerOfCanvas());
  items.push({ type:'table', img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH });
  selectedIdx = items.length - 1;
  redraw();
});

/* 空欄マス目をオフスクリーンで描いてImage化 */
function makeGridStamp(cols, rows, cell) {
  const pad = 0; // 余白なし（必要なら調整）
  const w = cols * cell + pad*2;
  const h = rows * cell + pad*2;
  const off = document.createElement('canvas');
  off.width = w; off.height = h;
  const g = off.getContext('2d');

  g.fillStyle = '#ffffff';
  g.fillRect(0,0,w,h);

  // 軽い影付きの外枠（見やすくする程度）
  g.strokeStyle = '#9aa4b2';
  g.lineWidth = 2;
  g.strokeRect(0.5,0.5,w-1,h-1);

  // グリッド線
  g.strokeStyle = '#cbd5e1'; // 明るめグレー
  g.lineWidth = 1;
  g.beginPath();
  for (let c=1;c<cols;c++) {
    const x = pad + c*cell + 0.5;
    g.moveTo(x, pad);
    g.lineTo(x, h-pad);
  }
  for (let r=1;r<rows;r++) {
    const y = pad + r*cell + 0.5;
    g.moveTo(pad, y);
    g.lineTo(w-pad, y);
  }
  g.stroke();

  const img = new Image();
  img.src = off.toDataURL('image/png');
  return img;
}

/* =========================
   7) 入力：描画／選択／パン・ピンチ
========================= */
const pointers = new Map();          // id -> {x,y}
let pinchStart = null;               // {mid, dist, view}
let dragState = null;                // {kind:'move'|'resize', idx, start:{x,y}, itemStart:{x,y,w,h}}

function getEventPoint(e) { const r = canvas.getBoundingClientRect(); return { x:e.clientX - r.left, y:e.clientY - r.top }; }
function twoFingerInfo() {
  const arr = Array.from(pointers.values());
  const p0 = arr[0], p1 = arr[1];
  const mid = { x:(p0.x+p1.x)/2, y:(p1.y+p0.y)/2 };
  const dist = Math.hypot(p1.x-p0.x, p1.y-p0.y);
  return { mid, dist };
}
function hitTestItem(L) {
  for (let i=items.length-1;i>=0;i--) {
    const it = items[i];
    const inBody = (L.x>=it.x && L.x<=it.x+it.w && L.y>=it.y && L.y<=it.y+it.h);
    const hx = it.x + it.w, hy = it.y + it.h;
    const inHandle = (L.x>=hx-HANDLE_SIZE/2 && L.x<=hx+HANDLE_SIZE/2 && L.y>=hy-HANDLE_SIZE/2 && L.y<=hy+HANDLE_SIZE/2);
    if (inHandle) return { kind:'handle', idx:i };
    if (inBody) return { kind:'body', idx:i };
  }
  return { kind:'none', idx:-1 };
}

canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  const pt = getEventPoint(e);
  pointers.set(e.pointerId, pt);

  if (tool === 'select') {
    const L = screenToLogical(pt);
    const hit = hitTestItem(L);
    if (pointers.size === 1) {
      if (hit.kind === 'handle') {
        selectedIdx = hit.idx;
        dragState = { kind:'resize', idx:selectedIdx, start:L, itemStart:{ ...items[selectedIdx] } };
      } else if (hit.kind === 'body') {
        selectedIdx = hit.idx;
        dragState = { kind:'move', idx:selectedIdx, start:L, itemStart:{ ...items[selectedIdx] } };
      } else {
        selectedIdx = -1; dragState = null;
      }
      redraw();
    }
    if (pointers.size === 2) {
      const { mid, dist } = twoFingerInfo();
      pinchStart = { mid, dist, view:{...view} };
    }
    return;
  }

  // 描画（pen/hl）
  if (pointers.size === 1) {
    drawing = true;
    current = { mode:tool, width:(tool==='pen'?lineWidthPen:lineWidthHL), points:[ screenToLogical(pt) ] };
  } else if (pointers.size === 2) {
    const { mid, dist } = twoFingerInfo();
    pinchStart = { mid, dist, view:{...view} };
  }
  redraw();
}, { passive:false });

canvas.addEventListener('pointermove', (e)=>{
  if (!pointers.has(e.pointerId)) return;
  e.preventDefault();
  pointers.set(e.pointerId, getEventPoint(e));

  if (tool === 'select') {
    if (pointers.size === 1 && dragState && selectedIdx >= 0) {
      const L = screenToLogical(pointers.get(e.pointerId));
      const it = items[selectedIdx];
      if (dragState.kind === 'move') {
        const dx = L.x - dragState.start.x, dy = L.y - dragState.start.y;
        it.x = dragState.itemStart.x + dx; it.y = dragState.itemStart.y + dy;
      } else if (dragState.kind === 'resize') {
        const dw = L.x - dragState.start.x, dh = L.y - dragState.start.y;
        it.w = Math.max(20, dragState.itemStart.w + dw);
        it.h = Math.max(20, dragState.itemStart.h + dh);
      }
      redraw(); return;
    }
    if (pointers.size === 2) {
      const { mid, dist } = twoFingerInfo();
      if (!pinchStart) return;
      const base = pinchStart.view;
      let s = base.scale * (dist / pinchStart.dist);
      s = Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
      const Lx = (pinchStart.mid.x - base.tx) / base.scale;
      const Ly = (pinchStart.mid.y - base.ty) / base.scale;
      view.scale = s; view.tx = mid.x - Lx * s; view.ty = mid.y - Ly * s;
      redraw(); return;
    }
    return;
  }

  // 描画モード
  if (pointers.size === 1 && drawing && current) {
    current.points.push( screenToLogical(pointers.get(e.pointerId)) );
    redraw();
  } else if (pointers.size === 2 && pinchStart) {
    const { mid, dist } = twoFingerInfo();
    const base = pinchStart.view;
    let s = base.scale * (dist / pinchStart.dist);
    s = Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
    const Lx = (pinchStart.mid.x - base.tx) / base.scale;
    const Ly = (pinchStart.mid.y - base.ty) / base.scale;
    view.scale = s; view.tx = mid.x - Lx * s; view.ty = mid.y - Ly * s;
    redraw();
  }
}, { passive:false });

canvas.addEventListener('pointerup', (e)=>{
  e.preventDefault();

  if (tool === 'select') {
    dragState = null;
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinchStart = null;
    return;
  }

  if (drawing && current && pointers.size === 1) {
    const pt = pointers.get(e.pointerId);
    if (pt) current.points.push( screenToLogical(pt) );
    strokes.push(current);
  }
  drawing = false; current = null;

  pointers.delete(e.pointerId);
  if (pointers.size < 2) pinchStart = null;
  redraw();
}, { passive:false });

canvas.addEventListener('pointercancel', (e)=>{
  e.preventDefault();
  drawing = false; current = null; dragState = null;
  pointers.delete(e.pointerId);
  if (pointers.size < 2) pinchStart = null;
  redraw();
}, { passive:false });

/* =========================
   8) ツールバー動作
========================= */
const btns = {
  pen : document.getElementById('penBtn'),
  hl  : document.getElementById('hlBtn'),
  sel : document.getElementById('selectBtn')
};
function setTool(next) {
  tool = next;
  btns.pen.classList.toggle('active', tool==='pen');
  btns.hl .classList.toggle('active', tool==='hl');
  btns.sel.classList.toggle('active', tool==='select');
  if (tool!=='select') { selectedIdx = -1; dragState=null; redraw(); }
}
btns.pen.onclick = ()=> setTool('pen');
btns.hl.onclick  = ()=> setTool('hl');
btns.sel.onclick = ()=> setTool('select');

document.getElementById('undoBtn').onclick = ()=>{
  if (current) { current=null; drawing=false; redraw(); return; }
  if (strokes.length>0) { strokes.pop(); redraw(); return; }
  if (items.length>0) { items.pop(); selectedIdx=-1; redraw(); return; }
};
document.getElementById('clearPenBtn').onclick = ()=> { strokes.length=0; redraw(); };
document.getElementById('clearAllBtn').onclick = ()=>{
  if (!confirm('背景/スタンプ/描画をすべて消去します。よろしいですか？')) return;
  strokes.length=0; items.length=0; selectedIdx=-1; bgImg=null; bgSize={w:0,h:0}; redraw();
};
document.getElementById('saveBtn').onclick = ()=>{
  const a = document.createElement('a');
  a.download = `consult_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
  a.href = canvas.toDataURL('image/png');
  a.click();
};

/* =========================
   9) ユーティリティ
========================= */
function centerOfCanvas() {
  const r = canvas.getBoundingClientRect();
  return { x:r.width/2, y:r.height/2 };
}

/* =========================
   10) 初期化
========================= */
function init(){ setCanvasSize(); redraw(); }
init();
</script>
</body>
</html>

