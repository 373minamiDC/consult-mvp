<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>コンサル資料キット（スタライス連続筆記＋全機能）</title>
<style>
  :root {
    --bg:#f7f8fa; --panel:#ffffff; --line:#e5e7eb; --hover:#f0f3f8; --accent:#2563eb;
    --safe-area-top: env(safe-area-inset-top, 0px);
    --safe-area-right: env(safe-area-inset-right, 0px);
    --safe-area-bottom: env(safe-area-inset-bottom, 0px);
    --safe-area-left: env(safe-area-inset-left, 0px);
  }
  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#1f2937; }
  body { overflow:hidden; -webkit-text-size-adjust:100%; }
  * { -webkit-tap-highlight-color: transparent; }

  #wrap { display:flex; height:100vh; }

  /* 左サイドバー */
  #sidebar { width:340px; max-width:42vw; min-width:270px; background:var(--panel); border-right:1px solid var(--line);
    display:flex; flex-direction:column; gap:14px; padding:14px; box-sizing:border-box; overflow-y:auto;
    scroll-padding-bottom:20px; padding-bottom:calc(14px + env(safe-area-inset-bottom, 0px)); }
  #sidebar h2 { font-size:14px; margin:0 0 6px; color:#374151; }
  .section { padding:10px; border:1px solid var(--line); border-radius:12px; background:#fff; }
  .row { display:flex; gap:8px; }
  .full { width:100%; }
  .muted { color:#6b7280; font-size:12px; margin-top:6px; }
  button, label.as-btn, select, input[type=text], input[type=number], textarea {
    font-size:14px; border:1px solid var(--line); border-radius:10px; background:#fff; color:#111827; padding:8px 10px; box-sizing:border-box;
  }
  button, label.as-btn, select { cursor:pointer; }
  input[type=text], input[type=number], textarea { cursor:text; width:100%; }
  textarea { resize:vertical; min-height:70px; }
  button:hover, label.as-btn:hover { background:var(--hover); }
  button.active { outline:2px solid var(--accent); outline-offset:-2px; }
  input[type=file]{ display:none; }
  label.as-btn { display:block; width:100%; text-align:center; }

  .text-modal-overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; padding:20px; z-index:1100; background:rgba(15,23,42,0.45); }
  .text-modal { width:min(520px, 100%); background:#fff; border-radius:14px; padding:20px; box-shadow:0 16px 48px rgba(15,23,42,0.24); display:flex; flex-direction:column; gap:14px; }
  .text-modal h3 { margin:0; font-size:16px; color:#111827; }
  .text-modal textarea { width:100%; min-height:200px; resize:vertical; font-size:15px; line-height:1.6; border:1px solid var(--line); border-radius:10px; padding:10px 12px; box-sizing:border-box; }
  .text-modal .field { display:flex; flex-direction:column; gap:6px; }
  .text-modal .field label { font-size:13px; color:#4b5563; }
  .text-modal .field input[type=number] { width:120px; }
  .text-modal-actions { display:flex; justify-content:flex-end; gap:10px; }
  .text-modal-actions button { min-width:94px; }
  .text-modal-actions .primary { background:var(--accent); color:#fff; border-color:var(--accent); }

  /* 色スウォッチ */
  .swatch { width:28px; height:28px; border-radius:7px; border:1px solid var(--line); cursor:pointer; }
  .swatch.active { outline:2px solid var(--accent); outline-offset:-2px; }

  /* 見積書エディタ */
  #estimateEditor { display:none; }
  #estimateEditor h2 { display:flex; justify-content:space-between; align-items:center; }
  #estimateRows { display:flex; flex-direction:column; gap:10px; margin-top:10px; }
  .estimate-row { display:grid; gap:10px; grid-template-columns:repeat(2, minmax(0, 1fr));
    align-items:flex-start; padding:12px; border:1px solid var(--line); border-radius:12px; background:#f9fafb; }
  .estimate-row select, .estimate-row input { padding:6px 8px; }
  .estimate-row select, .estimate-row input, .estimate-row textarea { width:100%; }
  .estimate-row .estimate-tooth { display:grid; grid-template-columns:repeat(3, minmax(0,1fr)); gap:6px; grid-column:1/-1; }
  .estimate-row .estimate-tooth select { min-width:0; }
  .estimate-row .estimate-category,
  .estimate-row .estimate-treatment,
  .estimate-row .estimate-quantity,
  .estimate-row .estimate-price { min-width:0; }
  .estimate-row .estimate-note { grid-column:1/-1; min-width:0; min-height:52px; }
  .estimate-row .estimate-remove { grid-column:2; justify-self:end; align-self:center; }
  @media (max-width:600px){
    .estimate-row { grid-template-columns:1fr; }
    .estimate-row .estimate-remove { grid-column:auto; }
  }
  .mini-btn { padding:6px 10px; font-size:12px; border-radius:8px; }
  .estimate-summary { margin-top:14px; padding-top:10px; border-top:1px solid var(--line); display:flex; flex-direction:column;
gap:6px; }
  .estimate-summary strong { font-size:16px; }
  .estimate-loan { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .estimate-loan select { width:auto; min-width:110px; }
  /* 右側キャンバス */
  #main { flex:1; display:flex; flex-direction:column; min-width:0; position:relative; overflow:hidden; }
  #canvasPane { flex:1; position:relative; margin:12px; border:1px solid var(--line); border-radius:12px; background:#fff; touch-action:none; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; background:#fff; touch-action:none; }
  #hint { position:absolute; right:10px; bottom:10px; background:#0007; color:#fff; font-size:12px; padding:6px 8px; border-radius:8px; pointer-events:none; }

  @media (max-width: 900px) {
    body { overflow:auto; }
    #wrap { flex-direction:column; height:auto; }
    #sidebar { width:auto; max-width:none; border-right:none; border-bottom:1px solid var(--line); overflow:visible; }
    #canvasPane { margin:10px; height:calc(100vh - 420px); }
  }

  /* iOS テキスト選択/コールアウト抑止 */
  html, body, #canvasPane, canvas {
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
  }
</style>
</head>
<body>
<div id="wrap">
  <!-- 左サイドバー -->
  <aside id="sidebar">
    <!-- ページ -->
    <div class="section">
      <h2>ページ</h2>
      <div class="row">
        <button id="prevPageBtn" class="full">◀︎ 前</button>
        <div id="pageIndicator" class="full" style="text-align:center; padding:8px;">1 / 1</div>
        <button id="nextPageBtn" class="full">次 ▶︎</button>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="addPageBtn" class="full">ページ追加</button>
        <button id="deletePageBtn" class="full">現在ページ削除</button>
      </div>
      <div class="row" style="margin-top:6px">
        <select id="newPageTemplate" class="full">
          <option value="blank">白紙ページ</option>
          <option value="estimate">見積書ページ</option>
        </select>
      </div>
      <div class="muted">※ ページごとに背景・スタンプ・線を保持します</div>
    </div>

    <!-- 患者情報 -->
    <div class="section">
      <h2>患者情報</h2>
      <div class="row"><input id="ptName" class="full" type="text" placeholder="患者名"></div>
      <div class="row" style="margin-top:6px"><input id="ptId" class="full" type="text" placeholder="ID / 診察券番号"></div>
      <div class="muted">左上に小さく表示（保存にも反映）</div>
    </div>

    <!-- 見積 -->
    <div class="section" id="estimateEditor">
      <h2>見積書</h2>
      <div class="muted">見積書ページを選択すると編集できます</div>
      <div id="estimateRows"></div>
      <button id="addEstimateRowBtn" class="full" style="margin-top:10px">行を追加</button>
      <div class="estimate-summary">
        <strong id="estimateTotalDisplay">合計（税込）：¥0</strong>
        <div class="estimate-loan">
          <label for="loanMonthsSelect">デンタルローン回数</label>
          <select id="loanMonthsSelect">
            <option value="6">6 回</option><option value="12">12 回</option><option value="18">18 回</option>
            <option value="24">24 回</option><option value="36">36 回</option><option value="48">48 回</option><option value="60">60 回</option>
            <option value="72">72 回</option><option value="84">84 回</option><option value="96">96 回</option><option value="108">108 回</option><option value="120">120 回</option>
          </select>
          <div>月々約 <span id="estimateMonthlyDisplay">¥0</span></div>
        </div>
        <div class="muted">※ 年利3.9%で自動計算されます</div>
      </div>
    </div>

    <!-- 保存・共有 -->
    <div class="section">
      <h2>患者データ保存 / 共有</h2>
      <div class="row"><button id="exportPatientBtn" class="full">患者データを書き出し</button></div>
      <label class="as-btn" style="margin-top:6px"><input id="importPatientInput" type="file" accept="application/json">患者データを読み込む</label>
      <div class="muted">※ 保存したJSONをAirDropなどで共有すると他のiPadでも続きを開けます</div>
    </div>

    <!-- 描画 -->
    <div class="section">
      <h2>描画ツール</h2>
      <div class="row">
        <button id="penBtn" class="full active">ペン</button>
        <button id="hlBtn" class="full">蛍光</button>
        <button id="eraserBtn" class="full">消しゴム</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="selectBtn" class="full" title="スタンプの移動・回転・サイズ変更">選択</button>
        <button id="deleteSelectionBtn" class="full" title="選択中の背景・スタンプを削除" disabled>選択削除</button>
      </div>
      <div class="row" style="margin-top:8px; align-items:center">
        <div id="colorBlack" class="swatch active" title="黒" style="background:#111"></div>
        <div id="colorRed" class="swatch" title="赤" style="background:#e11d48"></div>
        <div id="colorBlue" class="swatch" title="青" style="background:#2563eb"></div>
        <div id="colorYel" class="swatch" title="黄" style="background:#f59e0b"></div>
        <span class="muted" style="margin-left:6px">※色はペンのみ</span>
      </div>
      <div class="row" id="eraserSizeRow" style="margin-top:8px; align-items:center; display:none">
        <span style="min-width:86px; font-size:13px; color:#4b5563;">消しゴムサイズ</span>
        <select id="eraserSize" class="full">
          <option value="12">細</option>
          <option value="24" selected>中</option>
          <option value="40">太</option>
        </select>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="undoBtn" class="full">元に戻す</button>
        <button id="clearPenBtn" class="full" title="手描きのみクリア">描画クリア</button>
      </div>
    </div>

    <!-- テキスト -->
    <div class="section">
      <h2>テキスト</h2>
      <div class="row">
        <button id="addTextBtn" class="full">テキストを追加</button>
      </div>
      <div class="muted">白紙ページで使用できます。追加後は選択ツールで配置・拡大縮小できます。</div>
    </div>

    <!-- 画像・QR・スタンプ -->
    <div class="section">
      <h2>画像・QR・既定スタンプ</h2>
      <label class="as-btn"><input id="bgInput" type="file" accept="image/*">背景画像を読み込む</label>
      <label class="as-btn" style="margin-top:6px"><input id="imageInput" type="file" accept="image/*" multiple>画像を追加</label>
      <div class="row" style="margin-top:8px"><select id="templateImageSelect" class="full"></select></div>
      <div class="row" style="margin-top:6px"><button id="placeTemplateImageBtn" class="full">テンプレ画像を配置</button></div>
      <div class="muted">※ template-images フォルダに追加した JPG / JPEG / JPGE / PNG ファイルがここに表示されます</div>
      <button id="qrBtn" class="full" title="URL/テキストを入力してQR配置">自由入力のQRを追加</button>
      <div class="row" style="margin-top:8px">
        <button id="implantBtn" class="full" title="インプラントスタンプ">インプラント</button>
        <button id="crownBtn" class="full" title="被せ物（クラウン）スタンプ">被せ物</button>
      </div>
      <button id="clearAllBtn" class="full" style="margin-top:8px" title="現在ページを全消去">現在ページ 全消去</button>
    </div>

    <!-- 説明QRプリセット -->
    <div class="section">
      <h2>説明QR（プリセット）</h2>
      <div class="row"><select id="qrPresetSelect" class="full"></select></div>
      <div class="row" style="margin-top:6px"><button id="placePresetBtn" class="full">この説明をQRで配置</button></div>
      <div class="row" style="margin-top:10px"><input id="presetLabel" class="full" type="text" placeholder="追加ラベル（例：インプラント説明）"></div>
      <div class="row" style="margin-top:6px"><input id="presetData" class="full" type="text" placeholder="URL または テキスト"></div>
      <div class="row" style="margin-top:6px"><button id="addPresetBtn" class="full">候補を追加</button></div>
      <div class="muted">※ 候補はブラウザに保存され、次回も表示されます</div>
    </div>

    <!-- 表示・出力 -->
    <div class="section">
      <h2>表示 / 出力</h2>
      <div class="row">
        <button id="toggleLinesBtn" class="full">罫線 ON/OFF</button>
        <button id="saveBtn" class="full">PDF保存（全ページ）</button>
      </div>
    </div>
  </aside>

  <!-- 右側キャンバス -->
  <main id="main">
    <div id="canvasPane">
      <canvas id="c"></canvas>
      <div id="hint">1本指/スタライス:描く　2本指:パン固定　上の丸=回転　右下=拡大縮小</div>
    </div>
  </main>
</div>

<!-- jsPDF -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
/* ===== 端末ジェスチャ抑止（iOS） ===== */
['gesturestart','gesturechange','gestureend'].forEach(t=>{
  window.addEventListener(t, e=>{ if (e.cancelable) e.preventDefault(); }, { passive:false });
});

/* ========================= 基本・状態 ========================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:true, desynchronized:true });
const pane = document.getElementById('canvasPane');
const strokeLayer = document.createElement('canvas');
const strokeCtx = strokeLayer.getContext('2d', { alpha:true }) || strokeLayer.getContext('2d');
const deleteSelectionBtn = document.getElementById('deleteSelectionBtn');
const eraserSizeRowEl = document.getElementById('eraserSizeRow');
const eraserSizeSelectEl = document.getElementById('eraserSize');
const addTextBtn = document.getElementById('addTextBtn');
const templateImageSelectEl = document.getElementById('templateImageSelect');
const placeTemplateImageBtn = document.getElementById('placeTemplateImageBtn');

const DEFAULT_TEMPLATE_IMAGES = [];
const templateImages = [];
const TEMPLATE_IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.jpge', '.png'];

const measureCanvas = document.createElement('canvas');
const measureCtx = measureCanvas.getContext('2d');

let tool = 'pen'; // 'pen' | 'hl' | 'eraser' | 'select'
let lineWidthPen = 3;
let lineWidthHL  = 16;
let penColor = '#111';
let eraserSize = 24;

let showLines = false;
const LINE_STEP = 30;

const HANDLE_SIZE = 16;
const ROT_HANDLE_OFFSET = 28;

const ESTIMATE_INTEREST_RATE = 0.039;
const currencyFormatter = new Intl.NumberFormat('ja-JP');

const TOOTH_SIDE_OPTIONS = ['', '右', '左'];
const TOOTH_VERTICAL_OPTIONS = ['', '上', '下'];
const TOOTH_NUMBER_OPTIONS = Array.from({length:8}, (_,i)=>String(i+1));
const QUANTITY_OPTIONS = Array.from({length:99}, (_,i)=>i+1);

const TREATMENT_GROUPS = [
  {
    id:'inlay', label:'インレー',
    items:[
      { id:'ceramic_inlay', label:'セラミックインレー', price:65000 },
      { id:'zirconia_inlay', label:'ジルコニアインレー', price:70000 },
      { id:'gold_inlay', label:'ゴールドインレー', price:100000 }
    ]
  },
  {
    id:'crown', label:'クラウン',
    items:[
      { id:'all_ceramic_crown', label:'オールセラミッククラウン', price:130000 },
      { id:'zirconia_ceramic_crown', label:'ジルコニアセラミッククラウン', price:150000 },
      { id:'full_zirconia_crown', label:'フルジルコニアクラウン', price:100000 },
      { id:'metal_bond_crown', label:'メタルボンドクラウン', price:120000 },
      { id:'gold_crown', label:'ゴールドクラウン', price:180000 }
    ]
  },
  {
    id:'denture', label:'入れ歯',
    items:[
      { id:'metal_base_denture', label:'金属床義歯', price:300000 },
      { id:'non_clasp_crown', label:'ノンクラスプクラウン', price:100000 }
    ]
  },
  {
    id:'implant', label:'インプラント',
    items:[
      { id:'fixture', label:'フィクスチャー＋オペ料（検査費用含む）', price:275000 },
      { id:'surgical_guide', label:'サージカルガイド', price:40000 },
      { id:'provisional_restoration', label:'プロビジョナルレストレーション', price:100000 },
      { id:'abutment_normal', label:'アバットメント（通常）', price:77000 },
      { id:'abutment_on1', label:'アバットメント（On1）', price:88000 },
      { id:'superstructure_zirconia', label:'上部構造（ジルコニアクラウン）', price:140000 },
      { id:'gbr', label:'GBR（骨造成）', price:80000 },
      { id:'socket_lift', label:'ソケットリフト', price:100000 },
      { id:'sinus_lift', label:'サイナスリフト', price:150000 },
      { id:'locator_abutment', label:'ロケーターアバットメント', price:100000 },
      { id:'implant_overdenture', label:'インプラント オーバーデンチャー', price:400000 }
    ]
  },
  {
    id:'hygienist', label:'衛生士メニュー',
    items:[
      { id:'pmtc', label:'PMTC', price:13200 },
      { id:'home_whitening', label:'ホームホワイトニング', price:33000 }
    ]
  }
];

function getSafeAreaInsets(){
  const style = getComputedStyle(document.documentElement);
  const parse = (prop)=>{
    const raw = style.getPropertyValue(prop);
    if (!raw) return 0;
    const num = Number.parseFloat(raw);
    return Number.isFinite(num) ? num : 0;
  };
  return {
    top: parse('--safe-area-top'),
    right: parse('--safe-area-right'),
    bottom: parse('--safe-area-bottom'),
    left: parse('--safe-area-left')
  };
}

function isTextItem(it){ return !!(it && it.type === 'text'); }
function normalizeTextItem(it){
  if (!it) return;
  it.text = typeof it.text === 'string' ? it.text : '';
  it.fontSize = Number.isFinite(it.fontSize) && it.fontSize > 0 ? it.fontSize : 24;
  it.lineHeight = Number.isFinite(it.lineHeight) && it.lineHeight > 0 ? it.lineHeight : Math.round(it.fontSize * 1.35);
  it.padding = Number.isFinite(it.padding) && it.padding >= 0 ? it.padding : 16;
  it.color = typeof it.color === 'string' && it.color.trim() ? it.color : '#111827';
  it.align = (it.align === 'center' || it.align === 'right') ? it.align : 'left';
  it.w = Number.isFinite(it.w) && it.w > 0 ? it.w : 320;
  const minHeight = it.lineHeight + it.padding * 2;
  if (!Number.isFinite(it.h) || it.h <= 0) it.h = minHeight;
  return it;
}

function computeTextLayout(it){
  const ctxForMeasure = measureCtx || ctx;
  const padding = it.padding || 0;
  const available = Math.max(8, it.w - padding * 2);
  const font = `${it.fontSize}px 'Noto Sans JP', system-ui, sans-serif`;
  const lines = wrapEstimateText(it.text || '', available, font, ctxForMeasure);
  const minHeight = it.lineHeight + padding * 2;
  const neededHeight = Math.max(minHeight, lines.length * it.lineHeight + padding * 2);
  return { lines, font, minHeight, neededHeight };
}

function ensureTextItemLayout(it){
  if (!it) return { lines:[''], font:"", minHeight:0, neededHeight:0 };
  normalizeTextItem(it);
  if (it.w < it.padding * 2 + 60) it.w = it.padding * 2 + 60;
  const layout = computeTextLayout(it);
  if (it.h < layout.minHeight) it.h = layout.minHeight;
  if (it.h < layout.neededHeight) it.h = layout.neededHeight;
  return layout;
}

function clonePlacedItem(it){
  if (!it) return null;
  const copy = { ...it };
  copy.x = (it.x || 0) + 24;
  copy.y = (it.y || 0) + 24;
  copy.angle = it.angle || 0;
  if (isTextItem(copy)){
    copy.text = typeof it.text === 'string' ? it.text : '';
    ensureTextItemLayout(copy);
  }
  return copy;
}

function createTextItem(text, fontSize){
  const size = Number.isFinite(fontSize) && fontSize>0 ? Math.round(fontSize) : 24;
  const item = {
    type:'text',
    text: text || '',
    fontSize:size,
    lineHeight:Math.round(size * 1.35),
    padding:16,
    color:'#111827',
    align:'left',
    x:0,
    y:0,
    w:360,
    h:120,
    angle:0
  };
  const layout = ensureTextItemLayout(item);
  item.h = layout.neededHeight;
  return item;
}

function openTextInputDialog({ title='テキスト', initialValue='', placeholder='', initialFontSize=24, minFontSize=8, maxFontSize=160 }={}){
  return new Promise((resolve)=>{
    let closed = false;
    const overlay = document.createElement('div');
    overlay.className = 'text-modal-overlay';
    const modal = document.createElement('div');
    modal.className = 'text-modal';

    const heading = document.createElement('h3');
    heading.textContent = title;
    modal.appendChild(heading);

    const textarea = document.createElement('textarea');
    textarea.value = initialValue || '';
    if (placeholder) textarea.placeholder = placeholder;
    modal.appendChild(textarea);

    const fontSizeField = document.createElement('div');
    fontSizeField.className = 'field';
    const fontSizeLabel = document.createElement('label');
    fontSizeLabel.textContent = '文字サイズ';
    const fontSizeInput = document.createElement('input');
    fontSizeInput.type = 'number';
    const defaultFont = Number.isFinite(initialFontSize) && initialFontSize>0 ? initialFontSize : 24;
    const minF = Number.isFinite(minFontSize) && minFontSize>0 ? minFontSize : 8;
    const maxF = Number.isFinite(maxFontSize) && maxFontSize>minF ? maxFontSize : Math.max(minF, 160);
    fontSizeInput.min = String(minF);
    fontSizeInput.max = String(maxF);
    fontSizeInput.value = String(Math.min(maxF, Math.max(minF, Math.round(defaultFont))));
    fontSizeField.appendChild(fontSizeLabel);
    fontSizeField.appendChild(fontSizeInput);
    modal.appendChild(fontSizeField);

    const actions = document.createElement('div');
    actions.className = 'text-modal-actions';

    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'キャンセル';
    const saveBtn = document.createElement('button');
    saveBtn.textContent = '保存';
    saveBtn.classList.add('primary');

    actions.appendChild(cancelBtn);
    actions.appendChild(saveBtn);
    modal.appendChild(actions);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);

    function readFontSize(){
      const num = Number.parseInt(fontSizeInput.value, 10);
      const fallback = Math.min(maxF, Math.max(minF, Math.round(defaultFont)));
      if (!Number.isFinite(num)) return fallback;
      return Math.min(maxF, Math.max(minF, num));
    }

    function cleanup(result){
      if (closed) return;
      closed = true;
      document.body.removeChild(overlay);
      document.removeEventListener('keydown', onKey);
      resolve(result);
    }

    function onKey(e){
      if (e.key === 'Escape'){ cleanup(null); }
      else if ((e.metaKey || e.ctrlKey) && e.key === 'Enter'){ cleanup({ text: textarea.value, fontSize: readFontSize() }); }
    }

    cancelBtn.addEventListener('click', ()=>cleanup(null));
    saveBtn.addEventListener('click', ()=>cleanup({ text: textarea.value, fontSize: readFontSize() }));
    overlay.addEventListener('click', (e)=>{ if (e.target === overlay) cleanup(null); });
    document.addEventListener('keydown', onKey);
    setTimeout(()=>{ textarea.focus(); textarea.select(); }, 10);
  });
}

/* ページデータ */
function makeEstimateRow(){ return { tooth:'', category:'', treatment:'', treatmentLabel:'', unitPrice:0, price:0, quantity:1, note:'' }; }
function makeEstimateData(){ return { rows:[makeEstimateRow()], loanMonths:12, interestRate:ESTIMATE_INTEREST_RATE }; }
function makeEmptyPage(kind='blank'){ return { kind, strokes:[], items:[], bg:null, estimate: kind==='estimate'? makeEstimateData(): null }; }

let pages = [makeEmptyPage('blank')];
let pageIndex = 0;
function currentPage(){ return pages[pageIndex]; }

/* ビューは固定スケール（パンのみ） */
const view = { scale:1, tx:0, ty:0 };

/* ========================= DPRとサイズ ========================= */
function setCanvasSize(){
  const dpr = window.devicePixelRatio || 1;
  const r = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(r.width*dpr));
  const h = Math.max(1, Math.floor(r.height*dpr));
  if (canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; }
  ensureStrokeLayerSize();
  ctx.setTransform(dpr,0,0,dpr,0,0);
  redraw();
}
new ResizeObserver(setCanvasSize).observe(pane);

/* ========================= 変換補助 ========================= */
function applyView(){
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.transform(view.scale,0,0,view.scale,view.tx,view.ty);
}
function screenToLogical(pt){
  return { x:(pt.x - view.tx)/view.scale, y:(pt.y - view.ty)/view.scale };
}

/* ========================= レンダリング ========================= */
function clearDevice(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
}
function redraw(){
  clearDevice();
  applyView();
  const pg = currentPage();

  if (pg.kind==='blank' && showLines) drawHorizontalLines(LINE_STEP);
  if (pg.bg) drawPlacedItem(pg.bg);
  if (pg.kind==='estimate') drawEstimatePage(pg);
  for (const it of pg.items) drawPlacedItem(it);
  drawStrokesLayer(pg);
  drawPatientInfo();

  // 選択ハンドル（選択中）
  if (bgSelected && pg.bg) drawSelectionHandles(pg.bg);
  if (selectedIdx>=0 && pg.items[selectedIdx]) drawSelectionHandles(pg.items[selectedIdx]);

  updateSelectionControls();
  updatePageIndicator();
  updateTextControls();
}
function drawHorizontalLines(step){
  ctx.save();
  ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1 / view.scale;
  const w = canvas.width / view.scale, h = canvas.height / view.scale;
  const startX = -view.tx / view.scale, startY = -view.ty / view.scale;
  const endX = startX + w, endY = startY + h;
  ctx.beginPath();
  const y0 = Math.floor(startY / step) * step;
  for (let y = y0; y < endY; y += step) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
  ctx.stroke();
  ctx.restore();
}
function wrapEstimateText(text, width, font, measureContext){
  const str = text == null ? '' : String(text);
  if (!width || width <= 0) return str ? [str] : [''];
  const targetCtx = measureContext || ctx;
  if (!targetCtx) return str ? [str] : [''];
  const prevFont = targetCtx.font;
  targetCtx.font = font;
  const lines = [];
  const paragraphs = str.split(/\r?\n/);
  for (const paragraph of paragraphs){
    if (paragraph === ''){ lines.push(''); continue; }
    let current = '';
    for (const ch of Array.from(paragraph)){
      const next = current + ch;
      if (targetCtx.measureText(next).width > width && current){
        lines.push(current);
        current = ch;
      } else {
        current = next;
      }
    }
    lines.push(current);
  }
  if (prevFont !== undefined) targetCtx.font = prevFont;
  return lines.length ? lines : [''];
}

function drawEstimatePage(pg){
  const est = ensureEstimateDataForPage(pg);
  const total = calculateEstimateTotal(est);
  const monthly = Math.round(calculateMonthlyPayment(total, est.loanMonths, est.interestRate || ESTIMATE_INTEREST_RATE));
  const patientName = document.getElementById('ptName')?.value.trim() || '';
  const patientId = document.getElementById('ptId')?.value.trim() || '';

  const logicalWidth = (canvas.width / (window.devicePixelRatio || 1)) / view.scale;
  const logicalHeight = (canvas.height / (window.devicePixelRatio || 1)) / view.scale;
  const safe = getSafeAreaInsets();
  const baseHMargin = Math.max(60, Math.min(90, logicalWidth * 0.06));
  const baseVMargin = Math.max(60, Math.min(90, logicalHeight * 0.075));
  const marginLeft = baseHMargin + safe.left;
  const marginRight = baseHMargin + safe.right;
  const marginTop = baseVMargin + safe.top;
  const marginBottom = baseVMargin + safe.bottom;
  const availableWidth = logicalWidth - marginLeft - marginRight;
  const invScale = 1 / view.scale;
  const innerPadding = 40 * invScale;
  const tableWidth = Math.max(0, availableWidth - innerPadding - 2 / view.scale);
  if (tableWidth <= 0) return;
  const tableX = marginLeft + (availableWidth - tableWidth) / 2 + 1 / view.scale;

  const headingFont = `${30 * invScale}px 'Noto Sans JP', system-ui, sans-serif`;
  const subHeadingFont = `${12 * invScale}px system-ui, sans-serif`;
  const bodyFontSize = 13;
  const bodyFont = `${bodyFontSize * invScale}px 'Noto Sans JP', system-ui, sans-serif`;
  const headerFont = `${12 * invScale}px system-ui, sans-serif`;
  const summaryLabelFont = `${13 * invScale}px system-ui, sans-serif`;
  const summaryValueFont = `${24 * invScale}px 'Noto Sans JP', system-ui, sans-serif`;
  const summaryMonthlyFont = `${16 * invScale}px 'Noto Sans JP', system-ui, sans-serif`;
  const footnoteFont = `${11 * invScale}px system-ui, sans-serif`;

  const cellPaddingX = 10 * invScale;
  const cellPaddingY = 8 * invScale;
  const lineHeight = bodyFontSize * 1.45 * invScale;
  const headerHeight = 34 * invScale;
  const minRowHeight = 46 * invScale;

  const columnDefs = [
    { key:'tooth',      label:'部位',          ratio:0.12, align:'left',   wrap:true },
    { key:'treatment',  label:'治療内容',      ratio:0.28, align:'left',   wrap:true },
    { key:'quantity',   label:'数量',          ratio:0.08, align:'center', wrap:false },
    { key:'unitPrice',  label:'単価（税込）',  ratio:0.15, align:'right',  wrap:false },
    { key:'total',      label:'金額（税込）',  ratio:0.16, align:'right',  wrap:false },
    { key:'note',       label:'備考',          ratio:0.21, align:'left',   wrap:true },
  ];

  const columnWidths = [];
  let accum = 0;
  columnDefs.forEach((col, idx)=>{
    if (idx === columnDefs.length - 1){
      columnWidths.push(tableWidth - accum);
    } else {
      const w = tableWidth * col.ratio;
      columnWidths.push(w);
      accum += w;
    }
  });
  const columnOffsets = [];
  let running = 0;
  for (let i=0;i<columnWidths.length;i++){ columnOffsets.push(running); running += columnWidths[i]; }

  const rowsInfo = est.rows.map((row)=>{
    const perColumn = columnDefs.map((col, idx)=>{
      let text = '';
      if (col.key === 'tooth') text = row.tooth || '';
      else if (col.key === 'treatment') text = row.treatmentLabel || row.treatment || '';
      else if (col.key === 'quantity') text = row.quantity ? String(row.quantity) : '';
      else if (col.key === 'unitPrice'){
        const unit = Number(row.unitPrice);
        text = unit > 0 ? formatCurrency(unit) : '';
      }
      else if (col.key === 'total'){
        const rowTotal = getRowTotal(row);
        text = rowTotal > 0 ? formatCurrency(rowTotal) : '';
      }
      else if (col.key === 'note') text = row.note || '';
      const availableWidth = columnWidths[idx] - cellPaddingX * 2;
      const lines = col.wrap ? wrapEstimateText(text, availableWidth, bodyFont) : [text || ''];
      const effectiveLines = lines.length ? lines : [''];
      const height = Math.max(minRowHeight, effectiveLines.length * lineHeight + cellPaddingY * 2);
      return { lines: effectiveLines, height };
    });
    const rowHeight = perColumn.reduce((max, cell)=>Math.max(max, cell.height), minRowHeight);
    return { columns: perColumn.map(cell=>({ ...cell, height: rowHeight })), height: rowHeight };
  });

  const tableTop = marginTop + 68 * invScale;
  const tableHeight = headerHeight + rowsInfo.reduce((sum, info)=>sum + info.height, 0);
  const tableBottom = tableTop + tableHeight;

  ctx.save();

  // 見出し
  ctx.fillStyle = '#111827';
  ctx.font = headingFont;
  ctx.textBaseline = 'top';
  ctx.textAlign = 'left';
  ctx.fillText('治療見積書', marginLeft, marginTop);

  ctx.font = subHeadingFont;
  ctx.fillStyle = '#6b7280';
  ctx.fillText('下記の内容にて治療費の目安をご案内いたします。', marginLeft, marginTop + 36 * invScale);

  if (patientName || patientId){
    const infoLines = [];
    if (patientName) infoLines.push(`${patientName} 様`);
    if (patientId) infoLines.push(`ID: ${patientId}`);
    ctx.font = `${13 * invScale}px 'Noto Sans JP', system-ui, sans-serif`;
    ctx.fillStyle = '#111827';
    ctx.textAlign = 'right';
    infoLines.forEach((line, idx)=>{
      ctx.fillText(line, tableX + tableWidth, marginTop + idx * (18 * invScale));
    });
  }

  ctx.textAlign = 'left';

  // テーブル背景
  ctx.fillStyle = '#f3f4f6';
  ctx.fillRect(tableX, tableTop, tableWidth, headerHeight);

  let rowY = tableTop + headerHeight;
  rowsInfo.forEach((info, idx)=>{
    ctx.fillStyle = idx % 2 === 0 ? '#ffffff' : '#f9fafb';
    ctx.fillRect(tableX, rowY, tableWidth, info.height);
    rowY += info.height;
  });

  // ヘッダ文字
  ctx.font = headerFont;
  ctx.fillStyle = '#374151';
  ctx.textBaseline = 'middle';
  columnDefs.forEach((col, idx)=>{
    const colX = tableX + columnOffsets[idx];
    const colWidth = columnWidths[idx];
    let textX = colX + cellPaddingX;
    let align = 'left';
    if (col.align === 'right'){ textX = colX + colWidth - cellPaddingX; align = 'right'; }
    else if (col.align === 'center'){ textX = colX + colWidth / 2; align = 'center'; }
    ctx.textAlign = align;
    ctx.fillText(col.label, textX, tableTop + headerHeight / 2);
  });

  // 行テキスト
  ctx.font = bodyFont;
  ctx.fillStyle = '#1f2937';
  ctx.textBaseline = 'top';
  rowY = tableTop + headerHeight;
  rowsInfo.forEach((info)=>{
    columnDefs.forEach((col, idx)=>{
      const colX = tableX + columnOffsets[idx];
      const colWidth = columnWidths[idx];
      let textX = colX + cellPaddingX;
      let align = 'left';
      if (col.align === 'right'){ textX = colX + colWidth - cellPaddingX; align = 'right'; }
      else if (col.align === 'center'){ textX = colX + colWidth / 2; align = 'center'; }
      ctx.textAlign = align;
      let textY = rowY + cellPaddingY;
      const lines = info.columns[idx].lines.length ? info.columns[idx].lines : [''];
      lines.forEach((line)=>{
        if (line){ ctx.fillText(line, textX, textY); }
        textY += lineHeight;
      });
    });
    rowY += info.height;
  });

  // 枠線
  ctx.strokeStyle = '#d1d5db';
  ctx.lineWidth = Math.max(1 * invScale, 0.5 * invScale);
  ctx.strokeRect(tableX, tableTop, tableWidth, tableHeight);
  let vX = tableX;
  columnDefs.forEach((col, idx)=>{
    if (idx === 0) return;
    vX = tableX + columnOffsets[idx];
    ctx.beginPath();
    ctx.moveTo(vX, tableTop);
    ctx.lineTo(vX, tableBottom);
    ctx.stroke();
  });
  let hY = tableTop + headerHeight;
  rowsInfo.forEach((info)=>{
    ctx.beginPath();
    ctx.moveTo(tableX, hY);
    ctx.lineTo(tableX + tableWidth, hY);
    ctx.stroke();
    hY += info.height;
  });

  // サマリー
  const summaryWidth = Math.min(tableWidth, Math.max(320 * invScale, tableWidth * 0.38));
  const summaryHeight = 108 * invScale;
  const summaryX = tableX + tableWidth - summaryWidth;
  const bottomLimit = logicalHeight - marginBottom;
  let summaryGap = 28 * invScale;
  let footnoteSpacing = 20 * invScale;
  const minSummaryGap = 12 * invScale;
  const minFootnoteSpacing = 10 * invScale;
  const footnoteBlockHeight = 32 * invScale;
  const availableAfterTable = Math.max(0, bottomLimit - tableBottom);
  let requiredHeight = summaryGap + summaryHeight + footnoteSpacing + footnoteBlockHeight;
  if (requiredHeight > availableAfterTable){
    let excess = requiredHeight - availableAfterTable;
    const gapReduction = Math.min(summaryGap - minSummaryGap, excess);
    if (gapReduction > 0){
      summaryGap -= gapReduction;
      excess -= gapReduction;
    }
    if (excess > 0){
      const footnoteReduction = Math.min(footnoteSpacing - minFootnoteSpacing, excess);
      if (footnoteReduction > 0){
        footnoteSpacing -= footnoteReduction;
        excess -= footnoteReduction;
      }
    }
    if (excess > 0){
      summaryGap = Math.max(0, summaryGap - excess);
    }
  }
  let summaryY = tableBottom + summaryGap;
  if (summaryY + summaryHeight > bottomLimit){
    summaryY = Math.max(marginTop, bottomLimit - (summaryHeight + footnoteSpacing + footnoteBlockHeight));
  }
  summaryY = Math.max(marginTop, summaryY);
  let footnoteY = summaryY + summaryHeight + footnoteSpacing;
  if (footnoteY + footnoteBlockHeight > bottomLimit){
    footnoteSpacing = Math.max(0, bottomLimit - footnoteBlockHeight - (summaryY + summaryHeight));
    footnoteY = summaryY + summaryHeight + footnoteSpacing;
    if (footnoteY + footnoteBlockHeight > bottomLimit){
      footnoteY = Math.max(marginTop, bottomLimit - footnoteBlockHeight);
      footnoteSpacing = Math.max(0, footnoteY - (summaryY + summaryHeight));
    }
  }
  ctx.fillStyle = '#f9fafb';
  ctx.fillRect(summaryX, summaryY, summaryWidth, summaryHeight);
  ctx.strokeStyle = '#d1d5db';
  ctx.strokeRect(summaryX, summaryY, summaryWidth, summaryHeight);

  ctx.font = summaryLabelFont;
  ctx.fillStyle = '#374151';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('合計（税込）', summaryX + 16 * invScale, summaryY + 14 * invScale);

  ctx.font = summaryValueFont;
  ctx.fillStyle = '#111827';
  ctx.textAlign = 'right';
  ctx.fillText(formatCurrency(total), summaryX + summaryWidth - 16 * invScale, summaryY + 10 * invScale);

  ctx.font = summaryLabelFont;
  ctx.fillStyle = '#374151';
  ctx.textAlign = 'left';
  ctx.fillText('デンタルローンご利用時の目安', summaryX + 16 * invScale, summaryY + 56 * invScale);

  const monthlyText = monthly > 0 ? formatCurrency(monthly) : formatCurrency(0);
  ctx.font = summaryMonthlyFont;
  ctx.fillStyle = '#111827';
  ctx.textAlign = 'right';
  ctx.fillText(`月々 約 ${monthlyText}`, summaryX + summaryWidth - 16 * invScale, summaryY + 52 * invScale);

  const ratePct = ((est.interestRate || ESTIMATE_INTEREST_RATE) * 100).toFixed(1);
  ctx.font = subHeadingFont;
  ctx.fillStyle = '#6b7280';
  ctx.textAlign = 'left';
  ctx.fillText(`(${est.loanMonths}回 / 年利${ratePct}%想定)`, summaryX + 16 * invScale, summaryY + 78 * invScale);

  // 備考・注釈
  ctx.font = footnoteFont;
  ctx.fillStyle = '#6b7280';
  ctx.textAlign = 'left';
  ctx.fillText('※ 診査結果により治療内容・費用が変更となる場合があります。', tableX, footnoteY);
  ctx.fillText('※ 保険診療費は別途発生する場合があります。担当スタッフまでご確認ください。', tableX, footnoteY + 16 * invScale);

  ctx.restore();
}
function drawPatientInfo(){
  const name = document.getElementById('ptName').value.trim();
  const id = document.getElementById('ptId').value.trim();
  if (!name && !id) return;
  ctx.save(); ctx.fillStyle='#374151'; ctx.font=`${12/view.scale}px system-ui, sans-serif`; ctx.textBaseline='top';
  ctx.fillText(`${name}${name && id ? ' ' : ''}${id}`, 10, 10);
  ctx.restore();
}
function ensureStrokeLayerSize(){
  if (!strokeCtx) return;
  if (strokeLayer.width!==canvas.width || strokeLayer.height!==canvas.height){
    strokeLayer.width = canvas.width;
    strokeLayer.height = canvas.height;
  }
}
function renderStroke(targetCtx, stroke){
  if (!targetCtx || !stroke || !stroke.points || stroke.points.length<2) return;
  targetCtx.save();
  targetCtx.lineCap='round';
  targetCtx.lineJoin='round';
  const mode = stroke.mode;
  if (mode==='pen'){
    targetCtx.globalCompositeOperation='source-over';
    targetCtx.globalAlpha=1;
    targetCtx.strokeStyle=stroke.color||penColor;
    targetCtx.lineWidth=stroke.width||lineWidthPen;
  } else if (mode==='hl'){
    targetCtx.globalCompositeOperation='source-over';
    targetCtx.globalAlpha=0.28;
    targetCtx.strokeStyle='#ffd600';
    targetCtx.lineWidth=stroke.width||lineWidthHL;
  } else if (mode==='eraser'){
    targetCtx.globalCompositeOperation='destination-out';
    targetCtx.globalAlpha=1;
    targetCtx.strokeStyle='rgba(0,0,0,1)';
    targetCtx.lineWidth=stroke.width||eraserSize;
  } else {
    targetCtx.globalCompositeOperation='source-over';
    targetCtx.globalAlpha=1;
    targetCtx.strokeStyle=stroke.color||penColor;
    targetCtx.lineWidth=stroke.width||lineWidthPen;
  }
  targetCtx.beginPath();
  targetCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
  for (let i=1;i<stroke.points.length;i++) targetCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
  targetCtx.stroke();
  targetCtx.restore();
}
function drawStrokesLayer(pg){
  if (!strokeCtx) return;
  ensureStrokeLayerSize();
  const dpr = window.devicePixelRatio || 1;
  strokeCtx.setTransform(1,0,0,1,0,0);
  strokeCtx.clearRect(0,0,strokeLayer.width, strokeLayer.height);
  strokeCtx.setTransform(dpr,0,0,dpr,0,0);
  strokeCtx.transform(view.scale,0,0,view.scale,view.tx,view.ty);
  if (pg && Array.isArray(pg.strokes)){
    for (const s of pg.strokes) renderStroke(strokeCtx, s);
  }
  if (current && current.points && current.points.length>1){
    renderStroke(strokeCtx, current);
  }
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.drawImage(strokeLayer, 0, 0);
  ctx.restore();
}
function updateSelectionControls(){
  if (!deleteSelectionBtn) return;
  const pg = currentPage();
  const hasBg = !!(bgSelected && pg && pg.bg);
  const hasItem = !!(selectedIdx>=0 && pg && pg.items && pg.items[selectedIdx]);
  deleteSelectionBtn.disabled = !(hasBg || hasItem);
}

function updateTextControls(){
  if (!addTextBtn) return;
  const pg = currentPage();
  const usable = !!(pg && pg.kind === 'blank');
  addTextBtn.disabled = !usable;
  if (!usable){
    addTextBtn.textContent = 'テキストを追加';
    return;
  }
  const hasSelectedText = !!(selectedIdx>=0 && pg.items && pg.items[selectedIdx] && isTextItem(pg.items[selectedIdx]));
  addTextBtn.textContent = hasSelectedText ? '選択テキストを編集' : 'テキストを追加';
}
function getItemCenter(it){ return { cx: it.x + it.w/2, cy: it.y + it.h/2 }; }
function drawPlacedItem(it){
  if (!it) return;
  const {cx, cy} = getItemCenter(it);
  ctx.save(); ctx.translate(cx, cy); ctx.rotate(it.angle||0);
  if (isTextItem(it)){
    const layout = ensureTextItemLayout(it);
    ctx.fillStyle = it.color || '#111827';
    ctx.textBaseline = 'top';
    let align = 'left';
    if (it.align === 'center') align = 'center';
    else if (it.align === 'right') align = 'right';
    ctx.textAlign = align;
    ctx.font = layout.font;
    const padding = it.padding || 0;
    let textX = -it.w/2 + padding;
    if (align === 'center') textX = 0;
    else if (align === 'right') textX = it.w/2 - padding;
    let textY = -it.h/2 + padding;
    const lineHeight = it.lineHeight || 32;
    layout.lines.forEach((line)=>{
      ctx.fillText(line, textX, textY);
      textY += lineHeight;
    });
  } else if (it.img){
    ctx.drawImage(it.img, -it.w/2, -it.h/2, it.w, it.h);
  }
  ctx.restore();
}
function drawSelectionHandles(it){
  const {cx, cy} = getItemCenter(it);
  ctx.save(); ctx.translate(cx, cy); ctx.rotate(it.angle||0);
  ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 1 / view.scale;
  ctx.setLineDash([4 / view.scale, 3 / view.scale]); ctx.strokeRect(-it.w/2, -it.h/2, it.w, it.h); ctx.setLineDash([]);
  const r = HANDLE_SIZE/2;
  ctx.fillStyle = '#2563eb'; ctx.fillRect(it.w/2 - r, it.h/2 - r, HANDLE_SIZE, HANDLE_SIZE);
  const rotY = -it.h/2 - ROT_HANDLE_OFFSET;
  ctx.beginPath(); ctx.moveTo(0, -it.h/2); ctx.lineTo(0, rotY); ctx.stroke();
  ctx.beginPath(); ctx.arc(0, rotY, HANDLE_SIZE*0.6, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

/* ========================= 当たり判定（選択ツール） ========================= */
function worldToLocal(pt, it){ const {cx, cy} = getItemCenter(it); const a = -(it.angle || 0); const dx = pt.x - cx, dy = pt.y - cy; return { x: dx*Math.cos(a) - dy*Math.sin(a), y: dx*Math.sin(a) + dy*Math.cos(a) }; }
function localHitTest(ptLocal, it){
  const halfW = it.w/2, halfH = it.h/2;
  const inBody = (ptLocal.x>=-halfW && ptLocal.x<=halfW && ptLocal.y>=-halfH && ptLocal.y<=halfH);
  const r = HANDLE_SIZE/2;
  const inResize = (ptLocal.x>=halfW-r && ptLocal.x<=halfW+r && ptLocal.y>=halfH-r && ptLocal.y<=halfH+r);
  const rotY = -halfH - ROT_HANDLE_OFFSET;
  const inRotate = ((ptLocal.x)**2 + (ptLocal.y-rotY)**2) <= (HANDLE_SIZE*0.6)**2;
  return { inBody, inResize, inRotate };
}
function hitTestItem(L){
  const pg=currentPage();
  for (let i=pg.items.length-1;i>=0;i--){
    const it=pg.items[i]; const local=worldToLocal(L,it); const h=localHitTest(local,it);
    if (h.inRotate) return {kind:'rotate', idx:i};
    if (h.inResize) return {kind:'resize', idx:i};
    if (h.inBody)   return {kind:'body', idx:i};
  }
  return {kind:'none', idx:-1};
}
function hitTestBackground(L){
  const bg=currentPage().bg; if (!bg) return {kind:'none', idx:-1};
  const local=worldToLocal(L,bg); const h=localHitTest(local,bg);
  if (h.inRotate) return {kind:'rotate', idx:-1};
  if (h.inResize) return {kind:'resize', idx:-1};
  if (h.inBody)   return {kind:'body', idx:-1};
  return {kind:'none', idx:-1};
}

/* ========================= 入力処理：描画（タッチ優先）/ 選択 / パン ========================= */
const pointers=new Map();
let dragState=null; // {target:'item'|'bg', kind:'move'|'resize'|'rotate', idx, start, itemStart, startAngleScreen?, handleStartLocal?}
let selectedIdx=-1; let bgSelected=false;

/* ---- 即時ストローク（タッチ優先） ---- */
let drawing=false; let current=null;

const LONG_PRESS_DURATION = 1000;
const LONG_PRESS_MOVE_TOLERANCE = 18;
let longPressTimer=null;
let longPressInfo=null; // { source:'touch'|'pointer', identifier, startPt }
let pendingStroke=null; // { source, identifier|pointerId, mode, color, width, startPt }

function clearLongPressWatcher(){
  if (longPressTimer){
    clearTimeout(longPressTimer);
    longPressTimer=null;
  }
  longPressInfo=null;
}

function startLongPressWatcher(info){
  clearLongPressWatcher();
  const startPt = info.startPt ? { x: info.startPt.x, y: info.startPt.y } : null;
  longPressInfo={ ...info };
  if (startPt){
    longPressInfo.startPt = startPt;
  }
  longPressTimer = setTimeout(()=>{
    longPressTimer=null;
    const activeInfo=longPressInfo;
    longPressInfo=null;
    if (activeInfo && tool!=='select'){
      setTool('select');
    }
  }, LONG_PRESS_DURATION);
}

function updateLongPressWatcherPosition(pt){
  if (!longPressInfo) return;
  const origin = longPressInfo.startPt || pt;
  if (!longPressInfo.startPt){
    longPressInfo.startPt = origin;
  }
  const dx = pt.x - origin.x;
  const dy = pt.y - origin.y;
  if ((dx*dx + dy*dy) > (LONG_PRESS_MOVE_TOLERANCE * LONG_PRESS_MOVE_TOLERANCE)){
    clearLongPressWatcher();
  }
}

function getEventPoint(e){ const r=canvas.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }
function getTouchPoint(t){ const r=canvas.getBoundingClientRect(); return {x:t.clientX-r.left, y:t.clientY-r.top}; }

function beginStroke(mode, color, width, startPt){
  current = { mode, color, width, points:[screenToLogical(startPt)] };
  drawing = true;
}
function appendStrokePoints(pts){
  if (!current || !pts.length) return;
  const arr=current.points;
  for (const p of pts){
    arr.push(screenToLogical(p));
  }
  redraw();
}
function endStroke(){
  if (!current) return;
  currentPage().strokes.push(current);
  current=null;
  drawing=false;
  redraw();
}

/* ---- Touch Events：スタライス（タッチ扱い）を完全対応 ---- */
function onTouchStart(e){
  if (e.cancelable) e.preventDefault();
  if (!e.touches || e.touches.length===0) return;
  const t = e.touches[0];
  const pt = getTouchPoint(t);
  const L = screenToLogical(pt);
  const hitItem = hitTestItem(L);
  const bgHit = hitItem.idx>=0 ? { kind:'none', idx:-1 } : hitTestBackground(L);
  if (hitItem.idx>=0 || bgHit.kind!=='none'){
    if (tool!=='select'){
      if (tool==='pen' || tool==='hl' || tool==='eraser'){
        const width = tool==='pen' ? lineWidthPen : tool==='hl' ? lineWidthHL : eraserSize;
        const color = tool==='pen' ? penColor : undefined;
        pendingStroke={ source:'touch', identifier:t.identifier, mode:tool, color, width, startPt:pt };
      }
      startLongPressWatcher({ source:'touch', identifier:t.identifier, startPt:pt });
    }
    return;
  }
  clearLongPressWatcher();
  pendingStroke=null;
  if (tool!=='pen' && tool!=='hl' && tool!=='eraser') return; // 選択ツール中は描画しない
  const width = tool==='pen' ? lineWidthPen : tool==='hl' ? lineWidthHL : eraserSize;
  const color = tool==='pen' ? penColor : undefined;
  beginStroke(tool, color, width, pt);
}
function onTouchMove(e){
  if (pendingStroke && pendingStroke.source==='touch'){
    const touch = Array.from(e.touches||[]).find(tt=>tt.identifier===pendingStroke.identifier);
    if (!touch){
      pendingStroke=null;
    } else if (!drawing){
      const currentPt = getTouchPoint(touch);
      const dx = currentPt.x - pendingStroke.startPt.x;
      const dy = currentPt.y - pendingStroke.startPt.y;
      if ((dx*dx + dy*dy) > (LONG_PRESS_MOVE_TOLERANCE * LONG_PRESS_MOVE_TOLERANCE)){
        clearLongPressWatcher();
        const { mode, color, width, startPt } = pendingStroke;
        pendingStroke=null;
        beginStroke(mode, color, width, startPt);
      }
    }
  }
  if (longPressInfo && longPressInfo.source==='touch'){
    const touch = Array.from(e.touches||[]).find(tt=>tt.identifier===longPressInfo.identifier);
    if (touch){
      updateLongPressWatcherPosition(getTouchPoint(touch));
    } else {
      clearLongPressWatcher();
    }
  }
  if (!drawing) return;
  if (e.cancelable) e.preventDefault();
  if (!e.touches || e.touches.length===0) return;
  const t = e.touches[0]; appendStrokePoints([getTouchPoint(t)]);
}
function onTouchEnd(e){
  if (e.cancelable) e.preventDefault();
  if (longPressInfo && longPressInfo.source==='touch'){
    const ended = Array.from(e.changedTouches||[]).some(tt=>tt.identifier===longPressInfo.identifier);
    if (ended) clearLongPressWatcher();
  }
  if (pendingStroke && pendingStroke.source==='touch'){
    const ended = Array.from(e.changedTouches||[]).some(tt=>tt.identifier===pendingStroke.identifier);
    if (ended) pendingStroke=null;
  }
  if (e.touches && e.touches.length>0) return;
  if (drawing) endStroke();
}
function onTouchCancel(e){
  if (e.cancelable) e.preventDefault();
  clearLongPressWatcher();
  pendingStroke=null;
  current=null; drawing=false; redraw();
}

/* ---- Pointer：選択操作＆マウス描画（必要なら） ---- */
function angleTo(it, ptWorld){ const {cx,cy}=getItemCenter(it); return Math.atan2(ptWorld.y-cy, ptWorld.x-cx); }
function worldPtFromEvent(e){ return screenToLogical(getEventPoint(e)); }

canvas.addEventListener('pointerdown',(e)=>{
  if (e.cancelable) e.preventDefault();
  const pt=getEventPoint(e); pointers.set(e.pointerId, pt);
  const pointerType = e.pointerType || '';
  const pg=currentPage();
  const L=screenToLogical(pt);
  let hit=hitTestItem(L);
  let bgHit = hit.idx>=0 ? {kind:'none', idx:-1} : hitTestBackground(L);
  const isDrawingTool = (tool==='pen' || tool==='hl' || tool==='eraser');
  const wantsMouseSelect = (pointerType==='mouse' && e.shiftKey);
  let startedDrawing=false;

  if (wantsMouseSelect && tool!=='select'){
    clearLongPressWatcher();
    pendingStroke=null;
    setTool('select');
  }

  if (tool!=='select' && (hit.idx>=0 || bgHit.kind!=='none')){
    if (pointerType==='mouse'){
      if (isDrawingTool && !e.shiftKey){
        clearLongPressWatcher();
        pendingStroke=null;
        const width = tool==='pen' ? lineWidthPen : tool==='hl' ? lineWidthHL : eraserSize;
        const color = tool==='pen' ? penColor : undefined;
        beginStroke(tool, color, width, pt);
        startedDrawing=true;
      } else {
        clearLongPressWatcher();
        pendingStroke=null;
        setTool('select');
      }
    } else {
      if (isDrawingTool){
        const width = tool==='pen' ? lineWidthPen : tool==='hl' ? lineWidthHL : eraserSize;
        const color = tool==='pen' ? penColor : undefined;
        pendingStroke={ source:'pointer', pointerId:e.pointerId, mode:tool, color, width, startPt:pt };
      }
      startLongPressWatcher({ source:'pointer', pointerId:e.pointerId, startPt:pt });
      return;
    }
  } else {
    clearLongPressWatcher();
    pendingStroke=null;
  }

  if (tool==='select'){
    hit=hitTestItem(L);
    if (hit.idx>=0){
      selectedIdx=hit.idx; bgSelected=false;
      const it=pg.items[selectedIdx];
      if (hit.kind==='rotate'){
        dragState={ target:'item', kind:'rotate', idx:selectedIdx, start:L, itemStart:{...it}, startAngleScreen:angleTo(it,L) };
      } else if (hit.kind==='resize'){
        const copy={...it}; dragState={ target:'item', kind:'resize', idx:selectedIdx, start:L, itemStart:copy, handleStartLocal:worldToLocal(L, copy) };
      } else {
        dragState={ target:'item', kind:'move', idx:selectedIdx, start:L, itemStart:{...it} };
      }
    } else {
      bgHit = hitTestBackground(L);
      if (bgHit.kind!=='none'){
        selectedIdx=-1; bgSelected=true;
        const bg=pg.bg;
        if (!bg){ dragState=null; }
        else if (bgHit.kind==='rotate'){
          dragState={ target:'bg', kind:'rotate', idx:-1, start:L, itemStart:{...bg}, startAngleScreen:angleTo(bg,L) };
        } else if (bgHit.kind==='resize'){
          const copy={...bg}; dragState={ target:'bg', kind:'resize', idx:-1, start:L, itemStart:copy, handleStartLocal:worldToLocal(L, copy) };
        } else {
          dragState={ target:'bg', kind:'move', idx:-1, start:L, itemStart:{...bg} };
        }
      } else {
        selectedIdx=-1; bgSelected=false; dragState=null;
      }
    }
    redraw();
    return;
  }

  // ペン/蛍光をPointerでも使いたい人向け（マウスや純正ペンでも可）
  if (!startedDrawing && (tool==='pen' || tool==='hl' || tool==='eraser')){
    const width = tool==='pen' ? lineWidthPen : tool==='hl' ? lineWidthHL : eraserSize;
    const color = tool==='pen' ? penColor : undefined;
    beginStroke(tool, color, width, pt);
  }
},{passive:false});

canvas.addEventListener('pointermove',(e)=>{
  if (e.cancelable) e.preventDefault();
  if (pendingStroke && pendingStroke.source==='pointer' && pendingStroke.pointerId===e.pointerId && !drawing){
    const currentPt = getEventPoint(e);
    const dx = currentPt.x - pendingStroke.startPt.x;
    const dy = currentPt.y - pendingStroke.startPt.y;
    if ((dx*dx + dy*dy) > (LONG_PRESS_MOVE_TOLERANCE * LONG_PRESS_MOVE_TOLERANCE)){
      clearLongPressWatcher();
      const { mode, color, width, startPt } = pendingStroke;
      pendingStroke=null;
      beginStroke(mode, color, width, startPt);
    }
  }
  if (longPressInfo && longPressInfo.source==='pointer' && longPressInfo.pointerId===e.pointerId){
    updateLongPressWatcherPosition(getEventPoint(e));
  }
  const pg=currentPage();

  if (tool==='select'){
    if (!dragState) return;
    const L=worldPtFromEvent(e);
    const target = dragState.target==='bg' ? pg.bg : pg.items[dragState.idx];
    if (!target) return;

    if (dragState.kind==='move'){
      const dx=L.x-dragState.start.x, dy=L.y-dragState.start.y;
      target.x=dragState.itemStart.x+dx; target.y=dragState.itemStart.y+dy; redraw();
    } else if (dragState.kind==='resize'){
      const localNow=worldToLocal(L, dragState.itemStart);
      const startLocal = dragState.handleStartLocal || {x:dragState.itemStart.w/2, y:dragState.itemStart.h/2};
      let scaleX = startLocal.x ? localNow.x / startLocal.x : 1;
      let scaleY = startLocal.y ? localNow.y / startLocal.y : 1;
      if (!Number.isFinite(scaleX) || scaleX===0) scaleX=1;
      if (!Number.isFinite(scaleY) || scaleY===0) scaleY=1;
      const baseW=dragState.itemStart.w, baseH=dragState.itemStart.h;
      let newW=Math.abs(baseW*scaleX);
      let newH=Math.abs(baseH*scaleY);
      if (isTextItem(target)){
        const padding = target.padding || 0;
        const minW = padding * 2 + 60;
        const minH = Math.max((target.lineHeight || 32) + padding * 2, 60);
        newW = Math.max(minW, newW);
        newH = Math.max(minH, newH);
      } else {
        newW = Math.max(40, newW);
        newH = Math.max(40, newH);
      }
      target.w=newW;
      target.h=newH;
      if (isTextItem(target)){
        ensureTextItemLayout(target);
      }
      const {cx,cy}=getItemCenter(dragState.itemStart);
      target.x=cx-target.w/2;
      target.y=cy-target.h/2;
      redraw();
    } else if (dragState.kind==='rotate'){
      const ang0=dragState.startAngleScreen; const ang1=angleTo(dragState.itemStart,L);
      target.angle=(dragState.itemStart.angle||0)+(ang1-ang0); redraw();
    }
    return;
  }

  // 追従描画（Pointer経由）
  if (drawing && (tool==='pen' || tool==='hl' || tool==='eraser')) appendStrokePoints([getEventPoint(e)]);
},{passive:false});

canvas.addEventListener('pointerup',(e)=>{
  if (e.cancelable) e.preventDefault();
  if (longPressInfo && longPressInfo.source==='pointer' && longPressInfo.pointerId===e.pointerId){
    clearLongPressWatcher();
  }
  if (pendingStroke && pendingStroke.source==='pointer' && pendingStroke.pointerId===e.pointerId){
    pendingStroke=null;
  }
  dragState=null;
  if (drawing) endStroke();
},{passive:false});

canvas.addEventListener('pointercancel',(e)=>{
  if (e.cancelable) e.preventDefault();
  if (longPressInfo && longPressInfo.source==='pointer' && longPressInfo.pointerId===e.pointerId){
    clearLongPressWatcher();
  }
  if (pendingStroke && pendingStroke.source==='pointer' && pendingStroke.pointerId===e.pointerId){
    pendingStroke=null;
  }
  dragState=null; current=null; drawing=false; redraw();
},{passive:false});

canvas.addEventListener('dblclick', async (e)=>{
  if (e.cancelable) e.preventDefault();
  const pg = currentPage();
  if (!pg) return;
  const pt = getEventPoint(e);
  const L = screenToLogical(pt);
  const hit = hitTestItem(L);
  if (hit.idx>=0){
    const it = pg.items[hit.idx];
    if (isTextItem(it)){
      const next = await openTextInputDialog({ title:'テキストを編集', initialValue: it.text || '', initialFontSize: it.fontSize || 24 });
      if (next == null) return;
      const textValue = (next.text || '').trim();
      if (!textValue) return;
      it.text = textValue;
      if (Number.isFinite(next.fontSize) && next.fontSize>0){
        it.fontSize = Math.round(next.fontSize);
        it.lineHeight = Math.round(it.fontSize * 1.35);
      }
      ensureTextItemLayout(it);
      selectedIdx = hit.idx;
      bgSelected = false;
      setTool('select');
      redraw();
    }
  }
});

document.addEventListener('keydown', (e)=>{
  if (!(e.metaKey || e.ctrlKey)) return;
  const key = typeof e.key === 'string' ? e.key.toLowerCase() : '';
  if (key !== 'c') return;
  const active = document.activeElement;
  if (active){
    const tag = active.tagName ? active.tagName.toLowerCase() : '';
    if (tag === 'input' || tag === 'textarea' || active.isContentEditable) return;
  }
  if (tool !== 'select') return;
  const pg = currentPage();
  if (!pg) return;
  if (selectedIdx>=0 && pg.items && pg.items[selectedIdx]){
    const clone = clonePlacedItem(pg.items[selectedIdx]);
    if (clone){
      pg.items.push(clone);
      selectedIdx = pg.items.length - 1;
      bgSelected = false;
      redraw();
      e.preventDefault();
    }
  }
});

/* Touch（スタライス/指での描画） */
canvas.addEventListener('touchstart', onTouchStart, { passive:false });
canvas.addEventListener('touchmove',  onTouchMove,  { passive:false });
canvas.addEventListener('touchend',   onTouchEnd,   { passive:false });
canvas.addEventListener('touchcancel',onTouchCancel,{ passive:false });

/* ========================= ツールUI ========================= */
const btns={
  pen:document.getElementById('penBtn'),
  hl:document.getElementById('hlBtn'),
  eraser:document.getElementById('eraserBtn'),
  sel:document.getElementById('selectBtn')
};
function updateToolUI(){
  if (btns.pen) btns.pen.classList.toggle('active', tool==='pen');
  if (btns.hl) btns.hl.classList.toggle('active', tool==='hl');
  if (btns.eraser) btns.eraser.classList.toggle('active', tool==='eraser');
  if (btns.sel) btns.sel.classList.toggle('active', tool==='select');
  if (eraserSizeRowEl) eraserSizeRowEl.style.display = tool==='eraser' ? 'flex' : 'none';
}
function setTool(next){
  clearLongPressWatcher();
  pendingStroke=null;
  tool=next;
  if (tool!=='select'){ selectedIdx=-1; bgSelected=false; dragState=null; }
  updateToolUI();
  redraw();
}
btns.pen?.addEventListener('click', ()=>setTool('pen'));
btns.hl?.addEventListener('click', ()=>setTool('hl'));
btns.eraser?.addEventListener('click', ()=>setTool('eraser'));
btns.sel?.addEventListener('click', ()=>setTool('select'));

if (addTextBtn){
  addTextBtn.addEventListener('click', async ()=>{
    const pg = currentPage();
    if (!pg || pg.kind !== 'blank'){
      alert('テキストは白紙ページでのみ追加できます。');
      return;
    }
    const selected = (selectedIdx>=0 && pg.items[selectedIdx] && isTextItem(pg.items[selectedIdx])) ? pg.items[selectedIdx] : null;
    const dialogTitle = selected ? 'テキストを編集' : 'テキストを追加';
    const result = await openTextInputDialog({
      title: dialogTitle,
      placeholder: selected ? '' : '表示したい文章を入力してください',
      initialValue: selected ? (selected.text || '') : '',
      initialFontSize: selected ? selected.fontSize || 24 : 24
    });
    if (result == null) return;
    const textValue = (result.text || '').trim();
    if (!textValue) return;
    const fontSize = Number.isFinite(result.fontSize) && result.fontSize>0 ? result.fontSize : (selected ? selected.fontSize : 24);
    if (selected){
      selected.text = textValue;
      selected.fontSize = Math.round(fontSize);
      selected.lineHeight = Math.round(selected.fontSize * 1.35);
      ensureTextItemLayout(selected);
      selectedIdx = pg.items.indexOf(selected);
    } else {
      const item = createTextItem(textValue, fontSize);
      const center = centerOfCanvasLogical();
      item.x = center.x - item.w/2;
      item.y = center.y - item.h/2;
      ensureTextItemLayout(item);
      pg.items.push(item);
      selectedIdx = pg.items.length - 1;
    }
    bgSelected = false;
    setTool('select');
    redraw();
  });
}
updateToolUI();
if (eraserSizeSelectEl){
  const initialSize = parseInt(eraserSizeSelectEl.value, 10);
  if (Number.isFinite(initialSize) && initialSize>0) eraserSize = initialSize;
  eraserSizeSelectEl.addEventListener('change', ()=>{
    const val = parseInt(eraserSizeSelectEl.value, 10);
    if (Number.isFinite(val) && val>0) eraserSize = val;
  });
}
if (deleteSelectionBtn){
  deleteSelectionBtn.addEventListener('click', ()=>{
    const pg=currentPage();
    if (!pg) return;
    if (bgSelected && pg.bg){
      pg.bg=null;
      bgSelected=false;
    } else if (selectedIdx>=0){
      pg.items.splice(selectedIdx,1);
      selectedIdx=-1;
    }
    dragState=null;
    redraw();
  });
}
updateSelectionControls();

[['colorBlack','#111'],['colorRed','#e11d48'],['colorBlue','#2563eb'],['colorYel','#f59e0b']].forEach(([id,col])=>{
  const el=document.getElementById(id);
  el.addEventListener('click', ()=>{
    ['colorBlack','colorRed','colorBlue','colorYel'].forEach(i=>document.getElementById(i).classList.remove('active'));
    el.classList.add('active'); penColor=col;
  });
});

/* ========================= Undo / クリア / 罫線 ========================= */
document.getElementById('undoBtn').onclick=()=>{
  const pg=currentPage();
  if (drawing && current){ current=null; drawing=false; redraw(); return; }
  if (pg.strokes.length>0){ pg.strokes.pop(); redraw(); }
};
document.getElementById('clearPenBtn').onclick=()=>{ const pg=currentPage(); pg.strokes.length=0; current=null; drawing=false; redraw(); };
document.getElementById('toggleLinesBtn').onclick=()=>{ showLines=!showLines; redraw(); };

/* ========================= ページ操作 ========================= */
function updatePageIndicator(){ document.getElementById('pageIndicator').textContent = `${pageIndex+1} / ${pages.length}`; }
document.getElementById('addPageBtn').onclick=()=>{ const t=(document.getElementById('newPageTemplate')||{}).value||'blank'; pages.splice(pageIndex+1,0, makeEmptyPage(t)); pageIndex++; selectedIdx=-1; bgSelected=false; redraw(); refreshEstimateEditor(); updatePageIndicator(); };
document.getElementById('prevPageBtn').onclick=()=>{ if (pageIndex>0){ pageIndex--; selectedIdx=-1; bgSelected=false; redraw(); refreshEstimateEditor(); updatePageIndicator(); } };
document.getElementById('nextPageBtn').onclick=()=>{ if (pageIndex<pages.length-1){ pageIndex++; selectedIdx=-1; bgSelected=false; redraw(); refreshEstimateEditor(); updatePageIndicator(); } };
document.getElementById('deletePageBtn').onclick=()=>{ if (pages.length===1){ alert('これ以上削除できません'); return; } if (!confirm(`ページ${pageIndex+1}を削除しますか？`)) return; pages.splice(pageIndex,1); pageIndex=Math.max(0, Math.min(pageIndex, pages.length-1)); selectedIdx=-1; bgSelected=false; redraw(); refreshEstimateEditor(); updatePageIndicator(); };

/* ========================= 背景・QR・スタンプ ========================= */
function centerOfCanvas(){ const r=canvas.getBoundingClientRect(); return {x:r.width/2, y:r.height/2}; }
function centerOfCanvasLogical(){ return screenToLogical(centerOfCanvas()); }

function refreshTemplateImageSelect(){
  if (!templateImageSelectEl) return;
  templateImageSelectEl.innerHTML = '';
  if (!templateImages.length){
    const opt=document.createElement('option');
    opt.value='';
    opt.textContent='テンプレート画像がありません';
    templateImageSelectEl.appendChild(opt);
    templateImageSelectEl.value='';
    templateImageSelectEl.disabled=true;
  } else {
    templateImages.forEach((name, idx)=>{
      const opt=document.createElement('option');
      opt.value=String(idx);
      opt.textContent=name;
      templateImageSelectEl.appendChild(opt);
    });
    templateImageSelectEl.disabled=false;
    templateImageSelectEl.value='0';
  }
  if (placeTemplateImageBtn){ placeTemplateImageBtn.disabled = templateImages.length===0; }
}

function normalizeTemplateImageName(name){
  if (typeof name !== 'string') return null;
  const trimmed = name.trim();
  if (!trimmed) return null;
  const sanitized = trimmed.replace(/\\/g, '/').split('/').filter(Boolean).pop();
  if (!sanitized || sanitized.includes('..')) return null;
  const lower = sanitized.toLowerCase();
  if (!TEMPLATE_IMAGE_EXTENSIONS.some(ext => lower.endsWith(ext))) return null;
  return sanitized;
}

function setTemplateImages(list){
  templateImages.length = 0;
  if (Array.isArray(list)){
    const seen = new Set();
    list.forEach(name => {
      const normalized = normalizeTemplateImageName(name);
      if (!normalized || seen.has(normalized)) return;
      seen.add(normalized);
      templateImages.push(normalized);
    });
  }
  refreshTemplateImageSelect();
}

async function fetchTemplateManifest(){
  try{
    const res = await fetch('template-images/templates.json', { cache:'no-store' });
    if (!res.ok) return [];
    const data = await res.json();
    if (!Array.isArray(data)) return [];
    return data;
  }catch(err){
    return [];
  }
}

async function fetchTemplateDirectoryListing(){
  try{
    const res = await fetch('template-images/', { cache:'no-store' });
    if (!res.ok) return [];
    const text = await res.text();
    const names = new Set();
    if (typeof DOMParser === 'function'){
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');
        doc.querySelectorAll('a[href]').forEach(a => {
          const href = a.getAttribute('href');
          if (!href) return;
          const decoded = decodeURIComponent(href.split('?')[0]);
          const normalized = normalizeTemplateImageName(decoded);
          if (normalized) names.add(normalized);
        });
      } catch(_err){ /* noop */ }
    }
    if (!names.size){
      const hrefRegex = /href\s*=\s*['"]([^'"]+)['"]/gi;
      let match;
      while ((match = hrefRegex.exec(text)) !== null){
        const href = match[1];
        if (!href) continue;
        const decoded = decodeURIComponent(href.split('?')[0]);
        const normalized = normalizeTemplateImageName(decoded);
        if (normalized) names.add(normalized);
      }
    }
    return Array.from(names);
  }catch(err){
    return [];
  }
}

async function loadTemplateImageList(){
  setTemplateImages(DEFAULT_TEMPLATE_IMAGES);
  if (typeof fetch!=='function') return;
  try{
    const manifestList = await fetchTemplateManifest();
    if (manifestList.length){
      setTemplateImages(manifestList);
      return;
    }
    const directoryList = await fetchTemplateDirectoryListing();
    if (directoryList.length){
      setTemplateImages(directoryList);
    }
  }catch(err){
    console.warn('テンプレート画像リストの取得に失敗しました', err);
  }
}

if (placeTemplateImageBtn){
  placeTemplateImageBtn.addEventListener('click', ()=>{
    if (!templateImages.length){ alert('テンプレート画像がありません'); return; }
    if (!templateImageSelectEl){ alert('画像を選択してください'); return; }
    const idx = parseInt(templateImageSelectEl.value, 10);
    const filename = templateImages[idx];
    if (!filename){ alert('画像を選択してください'); return; }
    const img = new Image();
    img.onload=()=>{
      const baseW = img.naturalWidth || img.width || 1;
      const baseH = img.naturalHeight || img.height || 1;
      const r = canvas.getBoundingClientRect();
      const maxW = r.width * 0.6;
      const maxH = r.height * 0.6;
      let scale = Math.min(maxW / baseW, maxH / baseH);
      if (!Number.isFinite(scale) || scale <= 0) scale = 1;
      scale = Math.min(scale, 1);
      const w = Math.max(40, baseW * scale);
      const h = Math.max(40, baseH * scale);
      const center = centerOfCanvas();
      const pg = currentPage();
      pg.items.push({ type:'template-image', templateName:filename, img, x:center.x - w/2, y:center.y - h/2, w, h, angle:0 });
      selectedIdx = pg.items.length - 1;
      bgSelected = false;
      redraw();
    };
    img.onerror=()=> alert('テンプレート画像の読み込みに失敗しました。');
    img.src = `template-images/${encodeURIComponent(filename)}`;
  });
}

document.getElementById('bgInput').addEventListener('change', (ev)=>{
  const file = ev.target.files?.[0]; if (!file) return;
  const url = URL.createObjectURL(file); const img = new Image();
  img.onload = ()=>{ const baseW=img.naturalWidth||img.width||1; const baseH=img.naturalHeight||img.height||1; const r=canvas.getBoundingClientRect();
    const maxW=r.width*0.8, maxH=r.height*0.8; let scale=Math.min(maxW/baseW, maxH/baseH); if (!Number.isFinite(scale)||scale<=0) scale=1; scale=Math.min(scale,1)*0.9;
    const w=Math.max(40, baseW*scale), h=Math.max(40, baseH*scale); const center=centerOfCanvas(); const pg=currentPage();
    pg.bg={ img, x:center.x-w/2, y:center.y-h/2, w, h, angle:0 }; selectedIdx=-1; bgSelected=true; redraw(); URL.revokeObjectURL(url); ev.target.value=''; };
  img.src = url;
});
document.getElementById('imageInput').addEventListener('change', (ev)=>{
  const files = Array.from(ev.target.files || []); if (!files.length) return;
  const center=centerOfCanvas(); const pg=currentPage();
  files.forEach((file, idx)=>{
    const url = URL.createObjectURL(file); const img = new Image();
    img.onload=()=>{ const baseW=img.naturalWidth||img.width||1; const baseH=img.naturalHeight||img.height||1; const r=canvas.getBoundingClientRect();
      const maxW=r.width*0.6, maxH=r.height*0.6; let scale=Math.min(maxW/baseW, maxH/baseH); if (!Number.isFinite(scale)||scale<=0) scale=1; scale=Math.min(scale,1);
      const w=Math.max(40, baseW*scale), h=Math.max(40, baseH*scale); const offset=idx*24;
      pg.items.push({ type:'image', img, x:center.x-w/2+offset, y:center.y-h/2+offset, w, h, angle:0 });
      selectedIdx=pg.items.length-1; bgSelected=false; redraw(); URL.revokeObjectURL(url);
    };
    img.onerror=()=>{ URL.revokeObjectURL(url); };
    img.src=url;
  });
  ev.target.value='';
});
document.getElementById('qrBtn').addEventListener('click', ()=>{ const data = prompt('QRにするURLまたはテキスト：', 'https://minami-dentalclinic.com'); if (!data) return; const size = 240; const src = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(data)}`; const img = new Image(); img.crossOrigin = 'anonymous'; img.onload = ()=>{ const initW=180, initH=180; const center = centerOfCanvas(); const pg = currentPage(); pg.items.push({ type:'qr', qrData:data, img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH, angle:0 }); selectedIdx = pg.items.length - 1; bgSelected=false; redraw(); }; img.onerror = ()=> alert('QR画像の取得に失敗しました。'); img.src = src; });
document.getElementById('implantBtn').addEventListener('click', ()=>{ const img = makeImplantStamp(); const initW=180, initH=320; const center = centerOfCanvas(); const pg = currentPage(); pg.items.push({ type:'implant', img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH, angle:0 }); selectedIdx = pg.items.length - 1; bgSelected=false; redraw(); });
document.getElementById('crownBtn').addEventListener('click', ()=>{ const img = makeCrownStamp(); const initW=260, initH=220; const center = centerOfCanvas(); const pg = currentPage(); pg.items.push({ type:'crown', img, x:center.x - initW/2, y:center.y - initH/2, w:initW, h:initH, angle:0 }); selectedIdx = pg.items.length - 1; bgSelected=false; redraw(); });

function makeImplantStamp(){ const w=180, h=320, off=document.createElement('canvas'); off.width=w; off.height=h; const g=off.getContext('2d');
  g.fillStyle = '#e5e7eb'; g.strokeStyle = '#9ca3af'; g.lineWidth = 2; g.beginPath(); g.roundRect(50, 20, 80, 50, 10); g.fill(); g.stroke();
  g.fillStyle = '#d1d5db'; g.fillRect(75, 70, 30, 18);
  g.fillStyle = '#cbd5e1'; g.strokeStyle = '#94a3b8'; g.lineWidth = 2; g.beginPath(); g.roundRect(60, 88, 60, 180, 20); g.fill(); g.stroke();
  g.strokeStyle = '#94a3b8'; g.lineWidth = 2; for (let y=100;y<250;y+=14){ g.beginPath(); g.moveTo(62,y); g.lineTo(118,y+16); g.stroke(); }
  g.fillStyle = '#cbd5e1'; g.beginPath(); g.moveTo(60,268); g.lineTo(120,268); g.lineTo(90,300); g.closePath(); g.fill(); g.stroke();
  g.fillStyle = 'rgba(0,0,0,0.05)'; g.beginPath(); g.ellipse(90, 310, 45, 8, 0, 0, Math.PI*2); g.fill();
  const img=new Image(); img.src=off.toDataURL('image/png'); return img; }
function makeCrownStamp(){ const w=260, h=220, off=document.createElement('canvas'); off.width=w; off.height=h; const g=off.getContext('2d');
  g.fillStyle = '#ffffff'; g.strokeStyle = '#94a3b8'; g.lineWidth = 2; g.beginPath();
  g.moveTo(40,140); g.bezierCurveTo(40,90, 70,60, 110,60); g.bezierCurveTo(125,35, 135,30, 150,60); g.bezierCurveTo(190,60, 220,90, 220,140);
  g.bezierCurveTo(220,175, 200,190, 130,190); g.bezierCurveTo(70,190, 40,175, 40,140); g.closePath(); g.fill(); g.stroke();
  g.fillStyle = 'rgba(255,255,255,0.7)'; g.beginPath(); g.ellipse(120,95,60,20,-0.4,0,Math.PI*2); g.fill();
  g.strokeStyle = '#cbd5e1'; g.lineWidth=1.5; g.beginPath(); g.moveTo(90,120); g.quadraticCurveTo(130,110,170,120);
  g.moveTo(110,140); g.quadraticCurveTo(130,135,150,140); g.stroke();
  g.fillStyle = 'rgba(0,0,0,0.06)'; g.beginPath(); g.ellipse(130,205,70,10,0,0,Math.PI*2); g.fill();
  const img=new Image(); img.src=off.toDataURL('image/png'); return img; }

/* ========================= 見積エディタ ========================= */
const estimateEditorEl = document.getElementById('estimateEditor');
const estimateRowsEl = document.getElementById('estimateRows');
const estimateTotalDisplayEl = document.getElementById('estimateTotalDisplay');
const estimateMonthlyDisplayEl = document.getElementById('estimateMonthlyDisplay');
const loanMonthsSelectEl = document.getElementById('loanMonthsSelect');
const addEstimateRowBtn = document.getElementById('addEstimateRowBtn');

function normalizeEstimateRow(row){
  if (!row || typeof row !== 'object') return makeEstimateRow();
  row.tooth = typeof row.tooth === 'string' ? row.tooth : '';
  row.category = typeof row.category === 'string' ? row.category : '';
  row.treatment = typeof row.treatment === 'string' ? row.treatment : '';
  row.treatmentLabel = typeof row.treatmentLabel === 'string' ? row.treatmentLabel : '';
  if (!row.treatmentLabel && row.category && row.treatment){
    const { item } = findTreatment(row.category, row.treatment);
    if (item) row.treatmentLabel = item.label;
  }
  const qty = parseInt(row.quantity, 10);
  row.quantity = Math.min(99, Math.max(1, Number.isFinite(qty) ? qty : 1));
  row.unitPrice = Number.isFinite(row.unitPrice) ? row.unitPrice : Number(row.unitPrice) || 0;
  const priceNum = Number(row.price);
  row.price = Number.isFinite(priceNum) ? priceNum : row.unitPrice * row.quantity;
  row.note = typeof row.note === 'string' ? row.note : '';
  return row;
}

function findTreatment(categoryId, treatmentId){
  const group = TREATMENT_GROUPS.find(g=>g.id===categoryId) || null;
  const item = group ? (group.items.find(it=>it.id===treatmentId) || null) : null;
  return { group, item };
}

function getRowTotal(row){
  const qty = Math.max(1, parseInt(row.quantity, 10) || 1);
  if (typeof row.price === 'number' && !Number.isNaN(row.price)) return Math.round(row.price);
  const base = Number(row.unitPrice) || 0;
  return Math.round(base * qty);
}

function calculateEstimateTotal(est){
  if (!est || !Array.isArray(est.rows)) return 0;
  return est.rows.reduce((sum,row)=> sum + getRowTotal(row), 0);
}

function calculateMonthlyPayment(amount, months, annualRate){
  if (!months || months <= 0 || !amount) return 0;
  const principal = Math.max(0, amount);
  const r = annualRate > 0 ? annualRate / 12 : 0;
  if (r === 0) return principal / months;
  return principal * r / (1 - Math.pow(1 + r, -months));
}

function formatCurrency(amount){
  if (!amount) return '¥0';
  const rounded = Math.round(amount);
  return `¥${currencyFormatter.format(rounded)}`;
}

function ensureEstimateDataForPage(pg){
  if (!pg) return null;
  if (!pg.estimate) pg.estimate = makeEstimateData();
  const est = pg.estimate;
  if (!Array.isArray(est.rows)) est.rows = [makeEstimateRow()];
  if (est.rows.length === 0) est.rows.push(makeEstimateRow());
  for (let i=0;i<est.rows.length;i++) est.rows[i] = normalizeEstimateRow(est.rows[i]);
  const months = parseInt(est.loanMonths, 10);
  est.loanMonths = Math.min(120, Math.max(1, Number.isFinite(months) ? months : 12));
  est.interestRate = Number.isFinite(est.interestRate) ? est.interestRate : ESTIMATE_INTEREST_RATE;
  return est;
}

function serializeEstimate(est){
  if (!est || !Array.isArray(est.rows)) return {
    rows:[makeEstimateRow()],
    loanMonths:12,
    interestRate:ESTIMATE_INTEREST_RATE
  };
  return {
    rows: est.rows.map(row=>{
      const normalized = normalizeEstimateRow({...row});
      return {
        tooth: normalized.tooth || '',
        category: normalized.category || '',
        treatment: normalized.treatment || '',
        treatmentLabel: normalized.treatmentLabel || '',
        quantity: normalized.quantity || 1,
        unitPrice: Number(normalized.unitPrice) || 0,
        price: Number(normalized.price) || 0,
        note: normalized.note || ''
      };
    }),
    loanMonths: Math.min(120, Math.max(1, parseInt(est.loanMonths, 10) || 12)),
    interestRate: Number.isFinite(est.interestRate) ? est.interestRate : ESTIMATE_INTEREST_RATE
  };
}

function buildQuantityOptions(selectEl, value){
  selectEl.innerHTML = '';
  QUANTITY_OPTIONS.forEach(num=>{
    const opt = document.createElement('option');
    opt.value = String(num);
    opt.textContent = `${num}`;
    selectEl.appendChild(opt);
  });
  selectEl.value = String(value);
}

function ensureLoanOption(months){
  if (!loanMonthsSelectEl) return;
  const existing = Array.from(loanMonthsSelectEl.options).some(opt=>opt.value===String(months));
  if (!existing){
    const opt = document.createElement('option');
    opt.value = String(months);
    opt.textContent = `${months} 回`;
    loanMonthsSelectEl.appendChild(opt);
  }
}

function populateTreatmentOptions(selectEl, categoryId){
  selectEl.innerHTML = '';
  const blank = document.createElement('option');
  blank.value = '';
  blank.textContent = '治療内容';
  selectEl.appendChild(blank);
  const group = TREATMENT_GROUPS.find(g=>g.id===categoryId);
  if (group){
    group.items.forEach(item=>{
      const opt = document.createElement('option');
      opt.value = item.id;
      opt.textContent = item.label;
      selectEl.appendChild(opt);
    });
  }
}

function parseToothValue(value){
  const result = { side:'', arch:'', number:'' };
  if (typeof value !== 'string') return result;
  const match = value.match(/(右|左)(上|下)([1-8])/);
  if (!match) return result;
  result.side = match[1];
  result.arch = match[2];
  result.number = match[3];
  return result;
}

function combineToothValue(side, arch, number){
  const validSide = side === '右' || side === '左' ? side : '';
  const validArch = arch === '上' || arch === '下' ? arch : '';
  const numStr = TOOTH_NUMBER_OPTIONS.includes(String(number)) ? String(number) : '';
  return (validSide && validArch && numStr) ? `${validSide}${validArch}${numStr}` : '';
}

function createEstimateRowElement(row, index, est){
  const wrapper = document.createElement('div');
  wrapper.className = 'estimate-row';

  const toothWrapper = document.createElement('div');
  toothWrapper.className = 'estimate-tooth';

  const sideSelect = document.createElement('select');
  const sidePlaceholder = document.createElement('option');
  sidePlaceholder.value = '';
  sidePlaceholder.textContent = '左右';
  sideSelect.appendChild(sidePlaceholder);
  TOOTH_SIDE_OPTIONS.filter(Boolean).forEach(label=>{
    const opt = document.createElement('option');
    opt.value = label;
    opt.textContent = label;
    sideSelect.appendChild(opt);
  });

  const archSelect = document.createElement('select');
  const archPlaceholder = document.createElement('option');
  archPlaceholder.value = '';
  archPlaceholder.textContent = '上下';
  archSelect.appendChild(archPlaceholder);
  TOOTH_VERTICAL_OPTIONS.filter(Boolean).forEach(label=>{
    const opt = document.createElement('option');
    opt.value = label;
    opt.textContent = label;
    archSelect.appendChild(opt);
  });

  const numberSelect = document.createElement('select');
  const numberPlaceholder = document.createElement('option');
  numberPlaceholder.value = '';
  numberPlaceholder.textContent = '1-8';
  numberSelect.appendChild(numberPlaceholder);
  TOOTH_NUMBER_OPTIONS.forEach(num=>{
    const opt = document.createElement('option');
    opt.value = num;
    opt.textContent = num;
    numberSelect.appendChild(opt);
  });

  const parsedTooth = parseToothValue(row.tooth || '');
  sideSelect.value = parsedTooth.side || '';
  archSelect.value = parsedTooth.arch || '';
  numberSelect.value = parsedTooth.number || '';

  toothWrapper.appendChild(sideSelect);
  toothWrapper.appendChild(archSelect);
  toothWrapper.appendChild(numberSelect);
  wrapper.appendChild(toothWrapper);

  const categorySelect = document.createElement('select');
  categorySelect.classList.add('estimate-category');
  const catBlank = document.createElement('option');
  catBlank.value = '';
  catBlank.textContent = '治療種類';
  categorySelect.appendChild(catBlank);
  TREATMENT_GROUPS.forEach(group=>{
    const opt = document.createElement('option');
    opt.value = group.id;
    opt.textContent = group.label;
    categorySelect.appendChild(opt);
  });
  categorySelect.value = row.category || '';
  wrapper.appendChild(categorySelect);

  const treatmentSelect = document.createElement('select');
  treatmentSelect.classList.add('estimate-treatment');
  populateTreatmentOptions(treatmentSelect, row.category);
  treatmentSelect.value = row.treatment || '';
  if (!treatmentSelect.value && row.treatmentLabel){
    const matched = Array.from(treatmentSelect.options).find(opt=>opt.textContent===row.treatmentLabel);
    if (matched){
      treatmentSelect.value = matched.value;
      row.treatment = matched.value;
      row.treatmentLabel = matched.textContent;
    }
  }
  if (treatmentSelect.value){
    const { item } = findTreatment(row.category, treatmentSelect.value);
    if (item) row.treatmentLabel = item.label;
  }
  wrapper.appendChild(treatmentSelect);

  const quantitySelect = document.createElement('select');
  quantitySelect.classList.add('estimate-quantity');
  buildQuantityOptions(quantitySelect, row.quantity || 1);
  wrapper.appendChild(quantitySelect);

  const priceInput = document.createElement('input');
  priceInput.classList.add('estimate-price');
  priceInput.type = 'number';
  priceInput.min = '0';
  priceInput.step = '100';
  priceInput.value = String(Math.round(getRowTotal(row)) || 0);
  wrapper.appendChild(priceInput);

  const noteInput = document.createElement('textarea');
  noteInput.className = 'estimate-note';
  noteInput.placeholder = '備考';
  noteInput.value = row.note || '';
  wrapper.appendChild(noteInput);

  const removeBtn = document.createElement('button');
  removeBtn.type = 'button';
  removeBtn.className = 'mini-btn';
  removeBtn.classList.add('estimate-remove');
  removeBtn.textContent = '削除';
  wrapper.appendChild(removeBtn);

  const updateTooth = ()=>{
    row.tooth = combineToothValue(sideSelect.value, archSelect.value, numberSelect.value);
    redraw();
  };

  sideSelect.addEventListener('change', updateTooth);
  archSelect.addEventListener('change', updateTooth);
  numberSelect.addEventListener('change', updateTooth);

  categorySelect.addEventListener('change', ()=>{
    row.category = categorySelect.value;
    row.treatment = '';
    row.treatmentLabel = '';
    row.unitPrice = 0;
    row.price = 0;
    populateTreatmentOptions(treatmentSelect, row.category);
    treatmentSelect.value = '';
    priceInput.value = '0';
    updateEstimateSummaryOnly(est);
    redraw();
  });

  treatmentSelect.addEventListener('change', ()=>{
    row.treatment = treatmentSelect.value;
    const { item } = findTreatment(row.category, row.treatment);
    if (item){
      row.treatmentLabel = item.label;
      row.unitPrice = item.price;
      row.price = item.price * row.quantity;
    } else {
      row.treatmentLabel = '';
      row.unitPrice = 0;
      row.price = 0;
    }
    priceInput.value = String(Math.round(getRowTotal(row)) || 0);
    updateEstimateSummaryOnly(est);
    redraw();
  });

  quantitySelect.addEventListener('change', ()=>{
    const prevQty = row.quantity || 1;
    const newQty = Math.min(99, Math.max(1, parseInt(quantitySelect.value, 10) || 1));
    let unit = row.unitPrice;
    if ((!unit || unit <= 0) && row.price){
      unit = row.price / prevQty;
    }
    row.quantity = newQty;
    row.unitPrice = unit || 0;
    row.price = (unit || 0) * newQty;
    priceInput.value = String(Math.round(getRowTotal(row)) || 0);
    updateEstimateSummaryOnly(est);
    redraw();
  });

  priceInput.addEventListener('input', ()=>{
    const val = Number(priceInput.value);
    row.price = Number.isFinite(val) ? val : 0;
    const qty = row.quantity || 1;
    row.unitPrice = qty ? (row.price / qty) : row.price;
    updateEstimateSummaryOnly(est);
    redraw();
  });

  noteInput.addEventListener('input', ()=>{
    row.note = noteInput.value;
    redraw();
  });

  removeBtn.addEventListener('click', ()=>{
    if (est.rows.length <= 1){
      const blank = makeEstimateRow();
      Object.assign(row, blank);
    } else {
      est.rows.splice(index, 1);
    }
    refreshEstimateEditor();
    redraw();
  });

  return wrapper;
}

function updateEstimateSummaryOnly(est){
  if (!est || !estimateTotalDisplayEl || !estimateMonthlyDisplayEl) return;
  const total = calculateEstimateTotal(est);
  estimateTotalDisplayEl.textContent = `合計（税込）：${formatCurrency(total)}`;
  const monthly = calculateMonthlyPayment(total, est.loanMonths, est.interestRate || ESTIMATE_INTEREST_RATE);
  estimateMonthlyDisplayEl.textContent = formatCurrency(monthly);
}

function refreshEstimateEditor(){
  if (!estimateEditorEl || !estimateRowsEl || !estimateTotalDisplayEl || !estimateMonthlyDisplayEl) return;
  const pg = currentPage();
  if (!pg || pg.kind !== 'estimate'){
    estimateEditorEl.style.display = 'none';
    return;
  }

  const est = ensureEstimateDataForPage(pg);
  estimateEditorEl.style.display = 'block';
  ensureLoanOption(est.loanMonths);
  if (loanMonthsSelectEl){
    loanMonthsSelectEl.value = String(est.loanMonths);
  }

  estimateRowsEl.innerHTML = '';
  est.rows.forEach((row, idx)=>{
    estimateRowsEl.appendChild(createEstimateRowElement(row, idx, est));
  });

  updateEstimateSummaryOnly(est);
}

if (addEstimateRowBtn){
  addEstimateRowBtn.addEventListener('click', ()=>{
    const pg = currentPage();
    if (!pg || pg.kind !== 'estimate'){
      alert('見積書ページを選択してから行を追加してください。');
      return;
    }
    const est = ensureEstimateDataForPage(pg);
    est.rows.push(makeEstimateRow());
    refreshEstimateEditor();
    redraw();
  });
}

if (loanMonthsSelectEl){
  loanMonthsSelectEl.addEventListener('change', ()=>{
    const pg = currentPage();
    if (!pg || pg.kind !== 'estimate') return;
    const months = Math.min(120, Math.max(1, parseInt(loanMonthsSelectEl.value, 10) || 12));
    pg.estimate.loanMonths = months;
    loanMonthsSelectEl.value = String(months);
    refreshEstimateEditor();
    redraw();
  });
}


/* ========================= 保存/読み込み ========================= */
const PATIENT_EXPORT_VERSION = 3;
function imageToDataURL(img){ try{ const w=img.naturalWidth||img.width; const h=img.naturalHeight||img.height; if (!w||!h) return null; const off=document.createElement('canvas'); off.width=w; off.height=h; const g=off.getContext('2d'); g.drawImage(img,0,0,w,h); return off.toDataURL('image/png'); }catch{return null;} }
function dataURLToImage(dataUrl){ return new Promise((res,rej)=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>rej(new Error('画像読み込み失敗')); img.src=dataUrl; }); }
async function serializePatientData(){
  const patient={ name:document.getElementById('ptName').value.trim(), id:document.getElementById('ptId').value.trim() };
  const serializedPages=[]; let missingImages=false;
  for (const pg of pages){
    const strokes=pg.strokes.map(s=>({ mode:s.mode, width:s.width, color:s.color, points:s.points.map(p=>({x:p.x,y:p.y})) }));
    const items=[];
    for (const it of pg.items){
      if (isTextItem(it)){
        items.push({
          type:'text',
          x:it.x, y:it.y, w:it.w, h:it.h, angle:it.angle||0,
          text: it.text || '',
          fontSize: it.fontSize,
          lineHeight: it.lineHeight,
          padding: it.padding,
          color: it.color,
          align: it.align
        });
        continue;
      }
      if (!it || !it.img) continue;
      const imageData=imageToDataURL(it.img);
      if (!imageData){ missingImages=true; continue; }
      const savedItem = { type:it.type, x:it.x, y:it.y, w:it.w, h:it.h, angle:it.angle||0, imageData, qrData: it.type==='qr' ? it.qrData: undefined };
      if (it.templateName) savedItem.templateName = it.templateName;
      items.push(savedItem);
    }
    let bg=null; if (pg.bg){ const imageData=imageToDataURL(pg.bg.img); if (!imageData) missingImages=true;
      bg={ x:pg.bg.x, y:pg.bg.y, w:pg.bg.w, h:pg.bg.h, angle:pg.bg.angle||0, imageData }; }
    const pagePayload={ kind: pg.kind==='estimate' ? 'estimate' : 'blank', strokes, items, bg };
    if (pg.kind==='estimate'){ const est=ensureEstimateDataForPage(pg); pagePayload.estimate = serializeEstimate(est); }
    serializedPages.push(pagePayload);
  }
  const payload={ version:PATIENT_EXPORT_VERSION, exportedAt:new Date().toISOString(), patient, showLines, view:{...view}, pages:serializedPages };
  return { payload, missingImages };
}
async function restorePatientData(data){
  if (!data||typeof data!=='object') throw new Error('形式が正しくありません');
  const newPages=[];
  const pageList=Array.isArray(data.pages)?data.pages:[];
  for (const pgData of pageList){
    const kind = pgData && pgData.kind==='estimate' ? 'estimate' : 'blank';
    const pg = makeEmptyPage(kind);
    pg.strokes = Array.isArray(pgData.strokes)? pgData.strokes.map(s=>({ mode:(s.mode==='hl'?'hl':'pen'), width: typeof s.width==='number'?s.width:(s.mode==='hl'?lineWidthHL:lineWidthPen), color:s.color, points:Array.isArray(s.points)? s.points.map(p=>({x:p.x,y:p.y})) : [] })) : [];
    pg.items = [];
    if (Array.isArray(pgData.items)){
      for (const item of pgData.items){
        if (!item) continue;
        if (item.type === 'text' && typeof item.text === 'string'){
          const restored = {
            type:'text',
            text:item.text,
            fontSize: Number.isFinite(item.fontSize) && item.fontSize > 0 ? item.fontSize : 24,
            lineHeight: Number.isFinite(item.lineHeight) && item.lineHeight > 0 ? item.lineHeight : Math.round((Number.isFinite(item.fontSize) && item.fontSize > 0 ? item.fontSize : 24) * 1.35),
            padding: Number.isFinite(item.padding) && item.padding >= 0 ? item.padding : 16,
            color: typeof item.color === 'string' && item.color.trim() ? item.color : '#111827',
            align: (item.align === 'center' || item.align === 'right') ? item.align : 'left',
            x: typeof item.x === 'number' ? item.x : 0,
            y: typeof item.y === 'number' ? item.y : 0,
            w: typeof item.w === 'number' && item.w > 0 ? item.w : 320,
            h: typeof item.h === 'number' && item.h > 0 ? item.h : undefined,
            angle: typeof item.angle === 'number' ? item.angle : 0
          };
          ensureTextItemLayout(restored);
          pg.items.push(restored);
          continue;
        }
        if (!item.imageData) continue;
        try{
          const img = await dataURLToImage(item.imageData);
          const restored = { type:item.type||'qr', img, x:typeof item.x==='number'?item.x:0, y:typeof item.y==='number'?item.y:0,
            w:typeof item.w==='number'?item.w:(img.naturalWidth||img.width), h:typeof item.h==='number'?item.h:(img.naturalHeight||img.height), angle:typeof item.angle==='number'?item.angle:0 };
          if (restored.type==='qr' && item.qrData) restored.qrData=item.qrData;
          if (item.templateName) restored.templateName = item.templateName;
          pg.items.push(restored);
        }catch{}
      }
    }
    if (pgData.bg && pgData.bg.imageData){
      try{ const bgImg = await dataURLToImage(pgData.bg.imageData);
        pg.bg = { img:bgImg, x:pgData.bg.x||0, y:pgData.bg.y||0, w:pgData.bg.w||bgImg.width, h:pgData.bg.h||bgImg.height, angle:pgData.bg.angle||0 };
      }catch{}
    }
    if (kind==='estimate'){ const estData=pgData.estimate||{}; pg.estimate.rows = Array.isArray(estData.rows)&&estData.rows.length? estData.rows.map(r=>normalizeEstimateRow({...r})) : [makeEstimateRow()]; const loan=parseInt(estData.loanMonths,10); pg.estimate.loanMonths=Math.min(120,Math.max(1, Number.isFinite(loan)?loan:12)); const ir=Number(estData.interestRate); pg.estimate.interestRate=Number.isFinite(ir)?ir:ESTIMATE_INTEREST_RATE; }
    newPages.push(pg);
  }
  pages = newPages.length? newPages : [makeEmptyPage('blank')];
  pageIndex=0; selectedIdx=-1; bgSelected=false; current=null; drawing=false; dragState=null;
  document.getElementById('ptName').value = (data.patient||{}).name||'';
  document.getElementById('ptId').value   = (data.patient||{}).id||'';
  if (typeof data.showLines==='boolean') showLines=data.showLines;
  view.scale=1; view.tx=0; view.ty=0;
  redraw(); refreshEstimateEditor(); updatePageIndicator();
}
function sanitizeFileName(str){ return (str||'').replace(/[\\/:*?"<>|]/g,'_').slice(0,40)||'patient'; }

document.getElementById('exportPatientBtn').onclick=async()=>{
  try{ const {payload, missingImages} = await serializePatientData();
    const namePart = sanitizeFileName(payload.patient.id || payload.patient.name || 'patient');
    const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob); const a=document.createElement('a');
    a.href=url; a.download=`${namePart}_${ts}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a);
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
    if (missingImages) alert('一部の画像を取得できなかったため、書き出しデータに含まれない可能性があります。');
  }catch(e){ console.error(e); alert('患者データの書き出しに失敗しました。'); }
};
document.getElementById('importPatientInput').addEventListener('change', async(ev)=>{
  const file = ev.target.files?.[0]; if (!file) return;
  try{ const text = await file.text(); const data=JSON.parse(text); await restorePatientData(data); alert('患者データを読み込みました。'); }
  catch(e){ console.error(e); alert('患者データの読み込みに失敗しました。'); }
  finally{ ev.target.value=''; }
});

/* ========================= PDF保存（全ページ） ========================= */
document.getElementById('saveBtn').onclick=async()=>{
  const jspdf=window.jspdf; if (!jspdf||!jspdf.jsPDF){ alert('PDFライブラリ読み込みに失敗しました'); return; }
  const r=canvas.getBoundingClientRect(); if (!r.width||!r.height){ alert('キャンバスサイズ取得失敗'); return; }
  const orientation = r.width>=r.height ? 'landscape':'portrait';
  const pdf = new jspdf.jsPDF({ orientation, unit:'px', format:[r.width, r.height] });
  const prevIndex=pageIndex;
  try{
    for (let i=0;i<pages.length;i++){
      pageIndex=i; selectedIdx=-1; bgSelected=false; current=null; redraw();
      const dataUrl = await new Promise(res=>{ requestAnimationFrame(()=> res(canvas.toDataURL('image/png'))); });
      if (i>0) pdf.addPage([r.width, r.height], orientation);
      pdf.addImage(dataUrl, 'PNG', 0,0, r.width, r.height);
    }
    const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    pdf.save(`consult_pages_${ts}.pdf`);
  }catch(e){ console.error(e); alert('PDFの作成に失敗しました'); }
  finally{ pageIndex=prevIndex; redraw(); }
};

/* ========================= プリセットQR ========================= */
const PRESET_KEY='consult_qr_presets_v2';
const DEFAULT_PRESETS=[
 {label:'補綴物', data:'https://minami-dentalclinic.com/クラウンによる歯冠修復治療/'},
 {label:'CR', data:'https://minami-dentalclinic.com/コンポジットレジン修復（cr修復%EF%BC%8Fcr充填）/'},
 {label:'インレー', data:'https://minami-dentalclinic.com/インレー修復/'},
 {label:'ブリッジ', data:'https://minami-dentalclinic.com/ブリッジ/'},
 {label:'歯周治療', data:'https://minami-dentalclinic.com/歯周病治療/'},
 {label:'抜髄治療', data:'https://minami-dentalclinic.com/抜髄治療/'},
 {label:'感染根管治療', data:'https://minami-dentalclinic.com/感染根管治療/'},
 {label:'総義歯', data:'https://minami-dentalclinic.com/総義歯/'},
 {label:'部分床義歯', data:'https://minami-dentalclinic.com/部分床義歯/'},
 {label:'インプラント', data:'https://minami-dentalclinic.com/インプラント/'},
 {label:'中間欠損', data:'https://minami-dentalclinic.com/１歯欠損で両隣に歯がある場合の治療法（インプ/'},
 {label:'7番欠損', data:'https://minami-dentalclinic.com/７番欠損（６番は残存）時の治療法/'}
];
function loadPresets(){ const raw=localStorage.getItem(PRESET_KEY); let p=[]; if (raw){ try{ p=JSON.parse(raw)||[]; }catch{} } if (p.length===0){ p=DEFAULT_PRESETS.slice(); localStorage.setItem(PRESET_KEY, JSON.stringify(p)); } return p; }
function refreshPresetSelect(){ const sel=document.getElementById('qrPresetSelect'); const presets=loadPresets(); sel.innerHTML=''; presets.forEach((p,i)=>{ const opt=document.createElement('option'); opt.value=String(i); opt.textContent=p.label; sel.appendChild(opt); }); }
document.getElementById('placePresetBtn').onclick=()=>{
  const i=parseInt(document.getElementById('qrPresetSelect').value,10); const list=loadPresets();
  if (isNaN(i)||!list[i]){ alert('候補を選択してください'); return; }
  const data=list[i].data; const size=240; const src=`https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(data)}`;
  const img=new Image(); img.crossOrigin='anonymous';
  img.onload=()=>{ const initW=180, initH=180; const center=centerOfCanvas(); const pg=currentPage(); pg.items.push({ type:'qr', qrData:data, img, x:center.x-initW/2, y:center.y-initH/2, w:initW, h:initH, angle:0 }); selectedIdx=pg.items.length-1; bgSelected=false; redraw(); };
  img.onerror=()=>alert('QR画像の取得に失敗しました。'); img.src=src;
};
document.getElementById('addPresetBtn').onclick=()=>{
  const label=document.getElementById('presetLabel').value.trim();
  const data =document.getElementById('presetData').value.trim();
  if (!label||!data){ alert('ラベルとURL/テキストを入力してください'); return; }
  const list=loadPresets(); list.push({label,data}); localStorage.setItem(PRESET_KEY, JSON.stringify(list));
  document.getElementById('presetLabel').value=''; document.getElementById('presetData').value='';
  refreshPresetSelect(); alert('候補を追加しました');
};

/* ========================= 初期化 ========================= */
function init(){ refreshPresetSelect(); loadTemplateImageList(); setCanvasSize(); refreshEstimateEditor(); updatePageIndicator(); }
init();
</script>
</body>
</html>
