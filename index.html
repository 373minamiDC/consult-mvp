<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>コンサル資料キット（汎用スタライス対応・遅延ゼロ）</title>
<style>
  :root { --bg:#f7f8fa; --panel:#ffffff; --line:#e5e7eb; --hover:#f0f3f8; --accent:#2563eb; }
  html,body { height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#1f2937; }
  body { overflow:hidden; -webkit-text-size-adjust:100%; }
  * { -webkit-tap-highlight-color: transparent; }
  #wrap { display:flex; height:100vh; }

  /* サイドバー（最低限） */
  #sidebar {
    width:340px; max-width:42vw; min-width:270px;
    background:var(--panel); border-right:1px solid var(--line);
    display:flex; flex-direction:column; gap:14px; padding:14px; box-sizing:border-box; overflow-y:auto;
  }
  #sidebar h2 { font-size:14px; margin:0 0 6px; color:#374151; }
  .section { padding:10px; border:1px solid var(--line); border-radius:12px; background:#fff; }
  .row { display:flex; gap:8px; align-items:center; }
  .full { width:100%; }
  .muted { color:#6b7280; font-size:12px; margin-top:6px; }
  button, label.as-btn, select, input[type=text], input[type=number], textarea {
    font-size:14px; border:1px solid var(--line); border-radius:10px; background:#fff; color:#111827; padding:8px 10px; box-sizing:border-box;
  }
  button, label.as-btn, select { cursor:pointer; }
  input[type=text], input[type=number], textarea { cursor:text; width:100%; }
  textarea { resize:vertical; min-height:70px; }
  button:hover, label.as-btn:hover { background:var(--hover); }
  button.active { outline:2px solid var(--accent); outline-offset:-2px; }
  input[type=file]{ display:none; }
  label.as-btn { display:block; width:100%; text-align:center; }

  /* キャンバス（単一） */
  #main { flex:1; display:flex; flex-direction:column; min-width:0; position:relative; overflow:hidden; }
  #canvasPane {
    flex:1; position:relative; margin:12px; border:1px solid var(--line); border-radius:12px; background:#fff;
    touch-action:none;
  }
  canvas#c {
    position:absolute; inset:0; width:100%; height:100%; display:block; background:#fff;
    touch-action:none;
  }
  #hint {
    position:absolute; right:10px; bottom:10px; background:#0007; color:#fff; font-size:12px; padding:6px 8px; border-radius:8px;
    pointer-events:none;
  }
  @media (max-width: 900px) {
    body { overflow:auto; }
    #wrap { flex-direction:column; height:auto; }
    #sidebar { width:auto; max-width:none; border-right:none; border-bottom:1px solid var(--line); overflow:visible; }
    #canvasPane { margin:10px; height:calc(100vh - 420px); }
  }

  /* 色スウォッチ */
  .swatch { width:28px; height:28px; border-radius:7px; border:1px solid var(--line); cursor:pointer; }
  .swatch.active { outline:2px solid var(--accent); outline-offset:-2px; }

  /* iOSのテキスト選択/コールアウト抑止（全域） */
  html, body, #canvasPane, canvas#c {
    -webkit-user-select: none;
    user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
  }
</style>
</head>
<body>
<div id="wrap">
  <!-- 左サイドバー（必要なUIだけ） -->
  <aside id="sidebar">
    <div class="section">
      <h2>描画ツール</h2>
      <div class="row">
        <button id="penBtn" class="full active">ペン</button>
        <button id="hlBtn"  class="full">蛍光</button>
        <button id="undoBtn" class="full">元に戻す</button>
      </div>
      <div class="row" style="margin-top:8px; align-items:center">
        <div id="colorBlack" class="swatch active" title="黒" style="background:#111"></div>
        <div id="colorRed"   class="swatch" title="赤" style="background:#e11d48"></div>
        <div id="colorBlue"  class="swatch" title="青" style="background:#2563eb"></div>
        <div id="colorYel"   class="swatch" title="黄" style="background:#f59e0b"></div>
        <span class="muted" style="margin-left:6px">※色はペンのみ</span>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="clearPenBtn" class="full" title="手描きのみクリア">描画クリア</button>
      </div>
    </div>
  </aside>

  <!-- 右側キャンバス -->
  <main id="main">
    <div id="canvasPane">
      <canvas id="c"></canvas>
      <div id="hint">スタライスペン/指/マウス：描く（離してすぐ次を書けます）</div>
    </div>
  </main>
</div>

<script>
/* ===== OSのジェスチャ/クリック派生を全ブロック ===== */
['gesturestart','gesturechange','gestureend'].forEach(t=>{
  window.addEventListener(t, e=>{ if (e.cancelable) e.preventDefault(); }, { passive:false });
});
['click','dblclick','contextmenu'].forEach(t=>{
  document.addEventListener(t, e=>{
    // 描画中やキャンバスクリック時の合成クリックを殺す
    if (e.target === canvas || canvas.contains(e.target)) {
      if (e.cancelable) e.preventDefault();
      e.stopPropagation();
    }
  }, { capture:true, passive:false });
});

/* ========================= 基本セットアップ ========================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:true, desynchronized:true });
const pane = document.getElementById('canvasPane');

let tool = 'pen';              // 'pen' | 'hl'
let lineWidthPen = 3;
let lineWidthHL  = 16;
let penColor = '#111';

const strokes = []; // 既存ストロークのみ（ページ機能等は省略：まずは“書ける”最優先）

/* ========== DPRとサイズ ========== */
function setCanvasSize(){
  const dpr = window.devicePixelRatio || 1;
  const r = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(r.width*dpr));
  const h = Math.max(1, Math.floor(r.height*dpr));
  if (canvas.width!==w || canvas.height!==h){
    canvas.width = w; canvas.height = h;
  }
  ctx.setTransform(dpr,0,0,dpr,0,0);
  renderAll();
}
new ResizeObserver(setCanvasSize).observe(pane);

/* ========== 描画 ========== */
function clearDevice(){
  const dpr = window.devicePixelRatio || 1;
  const r = canvas.getBoundingClientRect();
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,r.width,r.height);
}
function renderAll(){
  clearDevice();
  for (const s of strokes) drawStroke(s);
}
function drawStroke(s){
  if (!s.points || s.points.length<2) return;
  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';
  if (s.mode==='pen'){ ctx.globalAlpha=1; ctx.strokeStyle=s.color||'#111'; ctx.lineWidth=s.width||lineWidthPen; }
  else { ctx.globalAlpha=0.28; ctx.strokeStyle='#ffd600'; ctx.lineWidth=s.width||lineWidthHL; }
  ctx.beginPath();
  ctx.moveTo(s.points[0].x, s.points[0].y);
  for (let i=1;i<s.points.length;i++) ctx.lineTo(s.points[i].x, s.points[i].y);
  ctx.stroke();
  ctx.restore();
}

/* ========== 即時ストローク ========== */
let drawing=false;
let currentStroke=null;

function getCanvasPointFromClient(x, y){
  const r = canvas.getBoundingClientRect();
  return { x: x - r.left, y: y - r.top };
}

/* ---- Touch Events（スタライスペン=タッチ扱いを確実にカバー） ---- */
function onTouchStart(e){
  if (e.cancelable) e.preventDefault();
  if (!e.touches || e.touches.length===0) return;
  // 複数本の指が来ても、最初の1本で描画（必要なら2本指パン等を後で実装）
  const t = e.touches[0];
  const p = getCanvasPointFromClient(t.clientX, t.clientY);
  beginStroke(tool, tool==='pen'?penColor:undefined, tool==='pen'?lineWidthPen:lineWidthHL, p);
}
function onTouchMove(e){
  if (!drawing) return;
  if (e.cancelable) e.preventDefault();
  if (!e.touches || e.touches.length===0) return;
  const t = e.touches[0];
  const p = getCanvasPointFromClient(t.clientX, t.clientY);
  appendStrokePoints([p]);
}
function onTouchEnd(e){
  if (e.cancelable) e.preventDefault();
  // 指が全部離れた時だけ確定
  if (e.touches && e.touches.length>0) return;
  if (drawing) endStroke();
}
function onTouchCancel(e){
  if (e.cancelable) e.preventDefault();
  cancelStroke();
}

/* ---- Pointer/Mouse もサポート（マウスでも同様に速い） ---- */
function onPointerDown(e){
  if (e.cancelable) e.preventDefault();
  const p = getCanvasPointFromClient(e.clientX, e.clientY);
  beginStroke(tool, tool==='pen'?penColor:undefined, tool==='pen'?lineWidthPen:lineWidthHL, p);
}
function onPointerMove(e){
  if (!drawing) return;
  if (e.cancelable) e.preventDefault();
  const p = getCanvasPointFromClient(e.clientX, e.clientY);
  appendStrokePoints([p]);
}
function onPointerUp(e){
  if (e.cancelable) e.preventDefault();
  if (drawing) endStroke();
}
function onPointerCancel(e){
  if (e.cancelable) e.preventDefault();
  cancelStroke();
}

/* ---- 核心：即時描画（再レンダを挟まない） ---- */
function beginStroke(mode, color, width, startPt){
  // 未確定が残っていたら掃除
  if (drawing && currentStroke) endStroke();
  currentStroke = { mode, color, width, points:[startPt] };
  drawing = true;
}
function appendStrokePoints(pts){
  if (!currentStroke || !pts.length) return;
  const arr = currentStroke.points;

  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';
  if (currentStroke.mode==='pen'){ ctx.globalAlpha=1; ctx.strokeStyle=currentStroke.color||'#111'; ctx.lineWidth=currentStroke.width||lineWidthPen; }
  else { ctx.globalAlpha=0.28; ctx.strokeStyle='#ffd600'; ctx.lineWidth=currentStroke.width||lineWidthHL; }

  let prev = arr[arr.length-1];
  ctx.beginPath(); ctx.moveTo(prev.x, prev.y);
  for (const p of pts){ arr.push(p); ctx.lineTo(p.x, p.y); }
  ctx.stroke();
  ctx.restore();
}
function endStroke(){
  if (!currentStroke) return;
  strokes.push(currentStroke);
  currentStroke=null; drawing=false;
}
function cancelStroke(){
  currentStroke=null; drawing=false;
}

/* ====== イベント登録（全て passive:false） ====== */
// Touch（スタライスペン最重要）
canvas.addEventListener('touchstart', onTouchStart, { passive:false });
canvas.addEventListener('touchmove',  onTouchMove,  { passive:false });
canvas.addEventListener('touchend',   onTouchEnd,   { passive:false });
canvas.addEventListener('touchcancel',onTouchCancel,{ passive:false });

// Pointer/Mouse
canvas.addEventListener('pointerdown', onPointerDown, { passive:false });
canvas.addEventListener('pointermove', onPointerMove, { passive:false });
canvas.addEventListener('pointerup',   onPointerUp,   { passive:false });
canvas.addEventListener('pointercancel', onPointerCancel, { passive:false });

/* ====== ツール＆色 ====== */
const btns={ pen:document.getElementById('penBtn'), hl:document.getElementById('hlBtn') };
function setTool(next){
  tool=next;
  btns.pen.classList.toggle('active', tool==='pen');
  btns.hl .classList.toggle('active', tool==='hl');
}
btns.pen.onclick=()=>setTool('pen');
btns.hl .onclick=()=>setTool('hl');

[['colorBlack','#111'],['colorRed','#e11d48'],['colorBlue','#2563eb'],['colorYel','#f59e0b']].forEach(([id,col])=>{
  const el=document.getElementById(id);
  el.addEventListener('click', ()=>{
    ['colorBlack','colorRed','colorBlue','colorYel'].forEach(i=>document.getElementById(i).classList.remove('active'));
    el.classList.add('active'); penColor=col;
  });
});

/* ====== Undo / クリア ====== */
document.getElementById('undoBtn').onclick=()=>{
  if (drawing && currentStroke){ currentStroke=null; drawing=false; return; }
  if (strokes.length>0){ strokes.pop(); renderAll(); }
};
document.getElementById('clearPenBtn').onclick=()=>{ strokes.length=0; renderAll(); };

/* ====== 初期化 ====== */
function init(){
  setCanvasSize();
  renderAll();
}
init();
</script>
</body>
</html>
