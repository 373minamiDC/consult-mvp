<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Consult MVP Canvas</title>
<style>
  html,body { height:100%; margin:0; background:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
  #wrap { height:100%; display:flex; flex-direction:column; }
  #toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; padding:10px; border-bottom:1px solid #e5e7eb; background:#f8f9fb; position:sticky; top:0; z-index:2 }
  #toolbar button, #toolbar label { appearance:none; border:1px solid #e5e7eb; background:#fff; border-radius:10px; padding:8px 10px; font-size:14px; cursor:pointer }
  #toolbar button.active { outline:2px solid #2563eb; outline-offset:-2px }
  #canvasPane { position:relative; flex:1; min-height:0 }
  canvas { position:absolute; inset:0; display:block; width:100%; height:100%; touch-action:none; background:#fff }
  #hint{position:absolute;right:10px;bottom:10px;background:#0008;color:#fff;padding:6px 10px;border-radius:8px;font-size:12px}
  .hidden-input { display:none; }
</style>
</head>
<body>
<div id="wrap">
  <div id="toolbar">
    <button id="penBtn" class="active">ペン</button>
    <button id="hlBtn">蛍光</button>
    <button id="selectBtn" title="画像/QRを動かす・サイズ変更">選択</button>

    <label title="背景（下敷き）を読み込み">
      <input id="bgInput" type="file" accept="image/*" class="hidden-input">画像読込（背景）
    </label>
    <label title="画面上に貼る画像スタンプを追加">
      <input id="stampInput" type="file" accept="image/*" class="hidden-input">スタンプ追加
    </label>
    <button id="qrBtn" title="URLからQRを生成してスタンプとして追加">QR追加</button>
    <button id="fitBtn" title="背景を画面にフィット">画像フィット</button>
    <button id="resetViewBtn">表示リセット</button>

    <button id="undoBtn">元に戻す</button>
    <button id="clearPenBtn" title="手描きのみ消去">手描きクリア</button>
    <button id="clearAllBtn" title="全部消去（背景も含む）">全消去</button>
    <button id="saveBtn">PNG保存</button>
  </div>

  <div id="canvasPane">
    <canvas id="c"></canvas>
    <div id="hint">1本指:描く/選択　2本指:パン&ズーム　枠の右下ハンドル:サイズ変更</div>
  </div>
</div>

<script>
/* ========= 基本セットアップ ========= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:true, desynchronized:true });
const pane = document.getElementById('canvasPane');

let tool = 'pen'; // 'pen' | 'hl' | 'select'
let lineWidth = 3;

/* ========= 論理モデル ========= */
// 手描き（ストローク）
const strokes = []; // [{mode,width,points:[{x,y}]}]
let drawing = false;
let current = null;

// 背景（下敷き）
let bgImg = null;          // Image
let bgSize = { w:0, h:0 }; // 論理座標サイズ

// 貼り付けオブジェクト（画像スタンプ/QR）
/* item: { type:'stamp'|'qr', img:HTMLImageElement, x,y,w,h }  (論理座標) */
const items = [];
let selectedIdx = -1;
const HANDLE_SIZE = 12; // 論理座標上のハンドル半径（見え方はズームに追随）

// ビュー（パン/ズーム）
const view = { scale:1, tx:0, ty:0 };
const MIN_SCALE = 0.3, MAX_SCALE = 6;

/* ========= DPR & サイズ ========= */
function setCanvasSize() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width * dpr));
  const h = Math.max(1, Math.floor(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; 
    canvas.height = h;
  }
  redraw();
}
new ResizeObserver(setCanvasSize).observe(pane);
window.addEventListener('resize', setCanvasSize, {passive:true});

/* ========= 座標変換 ========= */
function applyView() {
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.transform(view.scale,0,0,view.scale,view.tx,view.ty);
}
function screenToLogical(pt){ return { x:(pt.x - view.tx)/view.scale, y:(pt.y - view.ty)/view.scale }; }
function logicalToScreen(pt){ return { x:pt.x*view.scale + view.tx, y:pt.y*view.scale + view.ty }; }

/* ========= レンダリング ========= */
function clearAll() {
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
}
function redraw() {
  clearAll();
  applyView();

  // 背景
  if (bgImg && bgSize.w>0 && bgSize.h>0) {
    ctx.drawImage(bgImg, 0, 0, bgSize.w, bgSize.h);
  }

  // スタンプ/QR
  for (let i=0;i<items.length;i++) drawItem(items[i], i===selectedIdx);

  // 手描き
  for (const s of strokes) drawStroke(s);
  if (current) drawStroke(current);
}

function drawStroke(s) {
  const pts = s.points;
  if (!pts || pts.length < 2) return;

  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.miterLimit = 2;

  if (s.mode === 'pen') {
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = '#111';
  } else {
    ctx.globalAlpha = 0.28;
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = '#ffd600';
  }
  ctx.lineWidth = s.width ?? 3;

  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
  ctx.restore();
}

function drawItem(it, selected) {
  ctx.drawImage(it.img, it.x, it.y, it.w, it.h);
  if (!selected) return;

  // 選択枠とハンドル
  ctx.save();
  ctx.strokeStyle = '#2563eb';
  ctx.lineWidth = 1 / view.scale; // ズームしても見やすく
  ctx.setLineDash([4 / view.scale, 3 / view.scale]);
  ctx.strokeRect(it.x, it.y, it.w, it.h);
  ctx.setLineDash([]);

  // ハンドル（右下）
  const r = HANDLE_SIZE / 2;
  const cx = it.x + it.w, cy = it.y + it.h;
  ctx.fillStyle = '#2563eb';
  ctx.beginPath();
  ctx.rect(cx - r, cy - r, HANDLE_SIZE, HANDLE_SIZE);
  ctx.fill();
  ctx.restore();
}

/* ========= 背景＆スタンプ＆QR ========= */
document.getElementById('bgInput').addEventListener('change', (ev)=>{
  const file = ev.target.files?.[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = ()=>{
    bgImg = img;
    bgSize.w = img.naturalWidth;
    bgSize.h = img.naturalHeight;
    fitImageToView();
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

document.getElementById('stampInput').addEventListener('change', (ev)=>{
  const file = ev.target.files?.[0];
  if (!file) return;
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.onload = ()=>{
    const logicalW = Math.min(600, img.naturalWidth); // 初期幅を抑える
    const scale = logicalW / img.naturalWidth;
    const logicalH = img.naturalHeight * scale;
    const center = screenToLogical({x: canvas.getBoundingClientRect().width/2, y: canvas.getBoundingClientRect().height/2});
    items.push({ type:'stamp', img, x:center.x - logicalW/2, y:center.y - logicalH/2, w:logicalW, h:logicalH });
    selectedIdx = items.length - 1;
    redraw();
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

document.getElementById('qrBtn').addEventListener('click', async ()=>{
  const data = prompt('QRにするURLまたはテキストを入力してください：', 'https://minami-dentalclinic.com');
  if (!data) return;
  // 外部APIからPNGを取得（ブラウザ側でOK）
  const size = 512;
  const src = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(data)}`;
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    const logicalW = 240; // 初期サイズ（論理）
    const logicalH = 240;
    const center = screenToLogical({x: canvas.getBoundingClientRect().width/2, y: canvas.getBoundingClientRect().height/2});
    items.push({ type:'qr', img, x:center.x - logicalW/2, y:center.y - logicalH/2, w:logicalW, h:logicalH });
    selectedIdx = items.length - 1;
    redraw();
  };
  img.onerror = ()=> alert('QR画像の取得に失敗しました。ネットワークをご確認ください。');
  img.src = src;
});

/* 背景フィット */
function fitImageToView() {
  if (!bgImg) return;
  const r = canvas.getBoundingClientRect();
  const cssW = r.width, cssH = r.height;
  const sx = cssW / bgSize.w;
  const sy = cssH / bgSize.h;
  const s = Math.min(sx, sy);
  view.scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
  const screenImgW = bgSize.w * view.scale;
  const screenImgH = bgSize.h * view.scale;
  view.tx = (cssW - screenImgW)/2;
  view.ty = (cssH - screenImgH)/2;
  redraw();
}

/* ========= 入力（描画／選択／パンピンチ） ========= */
const pointers = new Map(); // id -> {x,y}
function getEventPoint(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

let pinchStart = null; // {mid,dist,view}
let dragState = null;  // 選択モード時 {kind:'move'|'resize', idx, start:{x,y}, itemStart:{x,y,w,h}}

canvas.addEventListener('pointerdown', (e)=>{
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  const pt = getEventPoint(e);
  pointers.set(e.pointerId, pt);

  if (tool === 'select') {
    const L = screenToLogical(pt);
    const hit = hitTestItem(L);
    if (pointers.size === 1) {
      if (hit.kind === 'handle') {
        selectedIdx = hit.idx;
        dragState = { kind:'resize', idx:selectedIdx, start:L, itemStart: { ...items[selectedIdx] } };
      } else if (hit.kind === 'body') {
        selectedIdx = hit.idx;
        dragState = { kind:'move', idx:selectedIdx, start:L, itemStart: { ...items[selectedIdx] } };
      } else {
        // 何も選ばれてなければ通常の描画に切り替え可能
        selectedIdx = -1;
      }
      redraw();
    }
    // 2本指→キャンバス ピンチ/パン
    if (pointers.size === 2) {
      const { mid, dist } = twoFingerInfo();
      pinchStart = { mid, dist, view:{...view} };
    }
    return;
  }

  // 描画モード（pen/hl）
  if (pointers.size === 1) {
    drawing = true;
    current = { mode:tool, width:(tool==='pen'?3:16), points:[ screenToLogical(pt) ] };
  } else if (pointers.size === 2) {
    // ピンチ開始
    const { mid, dist } = twoFingerInfo();
    pinchStart = { mid, dist, view:{...view} };
  }
  redraw();
},{passive:false});

canvas.addEventListener('pointermove', (e)=>{
  if (!pointers.has(e.pointerId)) return;
  e.preventDefault();
  pointers.set(e.pointerId, getEventPoint(e));

  if (tool === 'select') {
    if (pointers.size === 1 && dragState && selectedIdx >= 0) {
      const L = screenToLogical(pointers.get(e.pointerId));
      const it = items[selectedIdx];
      if (dragState.kind === 'move') {
        const dx = L.x - dragState.start.x;
        const dy = L.y - dragState.start.y;
        it.x = dragState.itemStart.x + dx;
        it.y = dragState.itemStart.y + dy;
      } else if (dragState.kind === 'resize') {
        let dw = L.x - dragState.start.x;
        let dh = L.y - dragState.start.y;
        it.w = Math.max(20, dragState.itemStart.w + dw);
        it.h = Math.max(20, dragState.itemStart.h + dh);
      }
      redraw();
      return;
    }
    if (pointers.size === 2) {
      // キャンバスのピンチ/パン
      const { mid, dist } = twoFingerInfo();
      const base = pinchStart?.view ?? view;
      if (!pinchStart) return;
      let s = base.scale * (dist / pinchStart.dist);
      s = Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
      const Lx = (pinchStart.mid.x - base.tx) / base.scale;
      const Ly = (pinchStart.mid.y - base.ty) / base.scale;
      view.scale = s;
      view.tx = mid.x - Lx * s;
      view.ty = mid.y - Ly * s;
      redraw();
      return;
    }
    return;
  }

  // 描画モード
  if (pointers.size === 1 && drawing && current) {
    current.points.push( screenToLogical(pointers.get(e.pointerId)) );
    redraw();
  } else if (pointers.size === 2 && pinchStart) {
    const { mid, dist } = twoFingerInfo();
    const base = pinchStart.view;
    let s = base.scale * (dist / pinchStart.dist);
    s = Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));
    const Lx = (pinchStart.mid.x - base.tx) / base.scale;
    const Ly = (pinchStart.mid.y - base.ty) / base.scale;
    view.scale = s;
    view.tx = mid.x - Lx * s;
    view.ty = mid.y - Ly * s;
    redraw();
  }
},{passive:false});

canvas.addEventListener('pointerup', (e)=>{
  e.preventDefault();

  if (tool === 'select') {
    dragState = null;
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinchStart = null;
    return;
  }

  if (drawing && current && pointers.size === 1) {
    const pt = pointers.get(e.pointerId);
    if (pt) current.points.push( screenToLogical(pt) );
    strokes.push(current);
  }
  drawing = false; current = null;

  pointers.delete(e.pointerId);
  if (pointers.size < 2) pinchStart = null;
  redraw();
},{passive:false});

canvas.addEventListener('pointercancel', (e)=>{
  e.preventDefault();
  drawing = false; current = null;
  dragState = null;
  pointers.delete(e.pointerId);
  if (pointers.size < 2) pinchStart = null;
  redraw();
},{passive:false});

/* ピンチ補助 */
function twoFingerInfo() {
  const arr = Array.from(pointers.values());
  const p0 = arr[0], p1 = arr[1];
  const mid = { x:(p0.x+p1.x)/2, y:(p0.y+p1.y)/2 };
  const dist = Math.hypot(p1.x-p0.x, p1.y-p0.y);
  return { mid, dist };
}

/* ヒットテスト（選択） */
function hitTestItem(L) {
  // 上にあるもの（末尾）からヒット
  for (let i=items.length-1;i>=0;i--) {
    const it = items[i];
    const inBody = (L.x>=it.x && L.x<=it.x+it.w && L.y>=it.y && L.y<=it.y+it.h);
    const hx = it.x + it.w, hy = it.y + it.h;
    const inHandle = (L.x>=hx-HANDLE_SIZE/2 && L.x<=hx+HANDLE_SIZE/2 && L.y>=hy-HANDLE_SIZE/2 && L.y<=hy+HANDLE_SIZE/2);
    if (inHandle) return { kind:'handle', idx:i };
    if (inBody) return { kind:'body', idx:i };
  }
  return { kind:'none', idx:-1 };
}

/* ========= ツールバー ========= */
const btns = {
  pen: document.getElementById('penBtn'),
  hl: document.getElementById('hlBtn'),
  sel: document.getElementById('selectBtn'),
};

function setTool(next){
  tool = next;
  btns.pen.classList.toggle('active', tool==='pen');
  btns.hl.classList.toggle('active', tool==='hl');
  btns.sel.classList.toggle('active', tool==='select');
  // 選択解除（選択モード以外に移る時）
  if (tool!=='select') { selectedIdx = -1; dragState=null; redraw(); }
}

btns.pen.onclick = ()=> setTool('pen');
btns.hl.onclick  = ()=> setTool('hl');
btns.sel.onclick = ()=> setTool('select');

document.getElementById('fitBtn').onclick = fitImageToView;
document.getElementById('resetViewBtn').onclick = ()=>{ view.scale=1; view.tx=0; view.ty=0; redraw(); };

document.getElementById('undoBtn').onclick = ()=>{
  // 直近の操作：手描き or スタンプ追加をざっくり取り消し（簡易実装）
  if (current) { current=null; drawing=false; redraw(); return; }
  if (strokes.length > 0) { strokes.pop(); redraw(); return; }
  if (items.length > 0) { items.pop(); selectedIdx=-1; redraw(); return; }
};

document.getElementById('clearPenBtn').onclick = ()=>{ strokes.length=0; redraw(); };
document.getElementById('clearAllBtn').onclick = ()=>{
  if (!confirm('背景やスタンプも含めて全て消去しますか？')) return;
  strokes.length=0; items.length=0; selectedIdx=-1; bgImg=null; bgSize={w:0,h:0}; redraw();
};

document.getElementById('saveBtn').onclick = ()=>{
  const a = document.createElement('a');
  a.download = `consult_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.png`;
  a.href = canvas.toDataURL('image/png');
  a.click();
};

/* ========= 初期化 ========= */
function init(){ setCanvasSize(); redraw(); }
init();
</script>
</body>
</html>
