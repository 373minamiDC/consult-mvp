<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<style>
  html,body { height:100%; margin:0; }
  #wrap { height:100%; display:flex; flex-direction:column; }
  #toolbar { padding:8px; gap:8px; display:flex; align-items:center; border-bottom:1px solid #ddd; }
  canvas { flex:1; display:block; background:#fff; touch-action: none; }
</style>
</head>
<body>
<div id="wrap">
  <div id="toolbar">
    <button id="penBtn">ペン</button>
    <button id="hlBtn">蛍光</button>
    <button id="undoBtn">取り消し</button>
    <button id="clearBtn">全消去</button>
    <button id="resetViewBtn">表示リセット</button>
  </div>
  <canvas id="c"></canvas>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true });
let mode = 'pen'; // 'pen' | 'hl'

// ------ 座標とストロージ ------
const strokes = []; // {mode, width, points:[{x,y}] }  ※論理座標で保存
let drawing = false;
let current = null;

// ------ ビュー変換（パン＆ズーム） ------
const view = { scale: 1, tx: 0, ty: 0 };
const MIN_SCALE = 0.3, MAX_SCALE = 6;

function applyView() {
  ctx.setTransform(view.scale, 0, 0, view.scale, view.tx, view.ty);
}
function screenToLogical(pt) {
  // 画面座標(px) → 論理座標（view逆変換）
  return {
    x: (pt.x - view.tx) / view.scale,
    y: (pt.y - view.ty) / view.scale
  };
}
function logicalToScreen(pt) {
  return {
    x: pt.x * view.scale + view.tx,
    y: pt.y * view.scale + view.ty
  };
}

// ------ DPRとキャンバスサイズ ------
function setCanvasSize() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width  * dpr));
  const h = Math.max(1, Math.floor(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
    ctx.setTransform(dpr,0,0,dpr,0,0); // 一旦DPR補正
    // 論理→画面は view に任せるので redraw 内で再設定
    redraw();
  }
}
new ResizeObserver(setCanvasSize).observe(document.getElementById('wrap'));
window.addEventListener('resize', setCanvasSize);

// ------ レンダリング ------
function redraw() {
  // まずDPR初期化（1:1）して全消去
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 論理→画面の変換を適用
  applyView();

  // ここで背景画像を敷くなら drawImage をこの座標系で
  // ctx.drawImage(bgImg, 0, 0);

  // 既存ストローク
  for (const s of strokes) drawStroke(s);
  // プレビュー
  if (current) drawStroke(current);
}

function drawStroke(s) {
  ctx.save();
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.miterLimit = 2;

  if (s.mode === 'pen') {
    ctx.globalAlpha = 1.0;
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = '#222';
    ctx.lineWidth = s.width ?? 2.5;
  } else {
    ctx.globalAlpha = 0.25;
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = '#ffd800';
    ctx.lineWidth = s.width ?? 16;
  }

  const pts = s.points;
  if (!pts || pts.length < 2) { ctx.restore(); return; }
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.stroke();
  ctx.restore();
}

// ------ ポインタ管理（1本＝描画 / 2本＝パン・ピンチ） ------
const pointers = new Map(); // id -> {x,y}
function getEventPoint(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

// ピンチの基準
let pinchStart = null; // {mid:{x,y}, dist:number, view:{scale,tx,ty}}
function twoFingerInfo() {
  const arr = Array.from(pointers.values());
  const p0 = arr[0], p1 = arr[1];
  const mid = { x:(p0.x+p1.x)/2, y:(p0.y+p1.y)/2 };
  const dx = p1.x - p0.x, dy = p1.y - p0.y;
  const dist = Math.hypot(dx, dy);
  return { mid, dist };
}

canvas.addEventListener('pointerdown', (e) => {
  e.preventDefault();
  canvas.setPointerCapture(e.pointerId);
  const pt = getEventPoint(e);
  pointers.set(e.pointerId, pt);

  if (pointers.size === 1) {
    // 1本指 → 描画モード
    const logical = screenToLogical(pt);
    drawing = true;
    current = { mode, points:[logical], width: mode==='pen' ? 2.5 : 16 };
  } else if (pointers.size === 2) {
    // 2本指 → パン・ピンチ開始（描画キャンセル）
    drawing = false;
    current = null;
    const { mid, dist } = twoFingerInfo();
    pinchStart = {
      mid, dist,
      view: { scale: view.scale, tx: view.tx, ty: view.ty }
    };
  }
  redraw();
}, { passive:false });

canvas.addEventListener('pointermove', (e) => {
  if (!pointers.has(e.pointerId)) return;
  e.preventDefault();
  pointers.set(e.pointerId, getEventPoint(e));

  if (pointers.size === 1 && drawing && current) {
    const onlyPt = pointers.get(e.pointerId);
    current.points.push(screenToLogical(onlyPt));
    redraw();
  } else if (pointers.size === 2 && pinchStart) {
    // ピンチ更新
    const { mid, dist } = twoFingerInfo();
    const s0 = pinchStart.view.scale;
    let s = s0 * (dist / pinchStart.dist);
    s = Math.min(MAX_SCALE, Math.max(MIN_SCALE, s));

    // 中点を固定する補正:
    // mid(画面) が pinchStart.mid と同じ論理点を指し続けるように tx,ty を調整
    // 論理座標で固定したい点 L を求める
    const Lx = (pinchStart.mid.x - pinchStart.view.tx) / pinchStart.view.scale;
    const Ly = (pinchStart.mid.y - pinchStart.view.ty) / pinchStart.view.scale;

    // その L が新しいスケールでも mid の画面位置に来るように tx,ty を設定
    view.scale = s;
    view.tx = mid.x - Lx * s;
    view.ty = mid.y - Ly * s;

    redraw();
  }
}, { passive:false });

canvas.addEventListener('pointerup', (e) => {
  e.preventDefault();
  const wasDrawing = drawing;
  if (drawing && current && pointers.size === 1) {
    // 1本指描画の終了
    const pt = pointers.get(e.pointerId);
    if (pt) current.points.push(screenToLogical(pt));
    strokes.push(current);
  }
  drawing = false; current = null;

  pointers.delete(e.pointerId);
  if (pointers.size < 2) pinchStart = null;
  redraw();
}, { passive:false });

canvas.addEventListener('pointercancel', (e) => {
  e.preventDefault();
  drawing = false; current = null;
  pointers.delete(e.pointerId);
  if (pointers.size < 2) pinchStart = null;
  redraw();
}, { passive:false });

// ------ ツールバー ------
document.getElementById('penBtn').onclick = () => mode='pen';
document.getElementById('hlBtn').onclick  = () => mode='hl';
document.getElementById('undoBtn').onclick = () => { strokes.pop(); redraw(); };
document.getElementById('clearBtn').onclick = () => { strokes.length=0; redraw(); };
document.getElementById('resetViewBtn').onclick = () => { view.scale=1; view.tx=0; view.ty=0; redraw(); };

// ------ 初期化 ------
function init() {
  setCanvasSize();
  redraw();
}
init();
</script>
</body>
</html>
